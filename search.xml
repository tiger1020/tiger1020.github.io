<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[zk分布式锁]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2Fzk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[主要依赖以下三个特性： 1.有序节点 2.临时节点: 3.watcher机制; 如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class DistributedLockWithZK implements Lock, Watcher &#123; private ZooKeeper zooKeeper = null; private String ROOT_LOCKS = "/lock"; //定义根节点 private String WAIT_LOCK;//等待前一个锁 private String CURRENT_LOCK; //表示当前的锁 private CountDownLatch countDownLatch; /** * 初始化zk */ public DistributedLockWithZK() &#123; try &#123; zooKeeper = new ZooKeeper("47.93.63.243:2181", 4000, this); //判断根节点是否存在 Stat stat = zooKeeper.exists(ROOT_LOCKS, false); if (stat == null) &#123; zooKeeper.create(ROOT_LOCKS, "0".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void lock() &#123; if (this.tryLock()) &#123; System.out.println(Thread.currentThread().getName() + "&gt;" + "获得锁成功!"); return; &#125; try &#123; waitForLock(WAIT_LOCK); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private boolean waitForLock(String prev) throws KeeperException, InterruptedException &#123; //监听上一个节点 Stat stat = zooKeeper.exists(prev, true); if (stat != null) &#123; System.out.println(Thread.currentThread().getName() + "&gt;等待锁---" + CURRENT_LOCK + "/" + prev + "释放锁!"); countDownLatch = new CountDownLatch(1); countDownLatch.await(); //todo 当watcher 触发后还需要再次判断当前等待的节点时候是最小的 System.out.println(Thread.currentThread().getName() + "&gt;获得锁"); &#125; return true; &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; &#125; /** * 尝试获得所 * * @return */ @Override public boolean tryLock() &#123; try &#123; CURRENT_LOCK = zooKeeper.create(ROOT_LOCKS + "/", "0".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(Thread.currentThread().getName() + "&gt;" + CURRENT_LOCK + "," + "尝试竞争锁!!"); //获得所有节点下面的子节点; List&lt;String&gt; childrens = zooKeeper.getChildren(ROOT_LOCKS, false); //定义一个集合进行排序 SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;(); for (String children : childrens) &#123; sortedSet.add(ROOT_LOCKS + "/" + children); &#125; //获得当前节点中的最小的子节点; String firstNode = sortedSet.first(); SortedSet&lt;String&gt; lessThenMe = ((TreeSet&lt;String&gt;) sortedSet).headSet(CURRENT_LOCK); //通过当前节点与最小节点进行比较 , 如果相等则获取所成功; if (CURRENT_LOCK.equals(firstNode)) &#123; return true; &#125; ///获得比当前节点更小的最后一个节点，设置给WAIT_LOCK if (!lessThenMe.isEmpty()) &#123; WAIT_LOCK = lessThenMe.last(); &#125; &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return false; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; @Override public void unlock() &#123; System.out.println(Thread.currentThread().getName()+"释放锁"+CURRENT_LOCK); try &#123; //设置version为-1 不管什么情况都要删除 zooKeeper.delete(CURRENT_LOCK,-1); CURRENT_LOCK=null; zooKeeper.close(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Condition newCondition() &#123; return null; &#125; @Override public void process(WatchedEvent watchedEvent) &#123; if (countDownLatch!=null)&#123; countDownLatch.countDown(); &#125; &#125;&#125; 调用demo 12345678910111213141516171819public class DistributedLockWithZKDemo &#123; public static void main(String[] args) throws IOException &#123; CountDownLatch countDownLatch = new CountDownLatch(10); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; countDownLatch.await(); DistributedLockWithZK distributedLockWithZK = new DistributedLockWithZK(); distributedLockWithZK.lock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,"Thread-"+i).start(); countDownLatch.countDown(); &#125; System.in.read() ; &#125;&#125;]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘宝diamond架构]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%2F%E6%B7%98%E5%AE%9Ddiamond%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.diamond架构 diamond的特点是简单、可靠、易用： 简单：整体结构非常简单，从而减少了出错的可能性。 易用：客户端使用只需要两行代码，暴露的接口都非常简单，易于理解。 2.diamond流程 2.1.server集群数据同步diamond-server将数据存储在mysql和本地文件中，mysql是一个中心，diamond认为存储在mysql中的数据绝对正确，除此之外，server会将数据存储在本地文件中。 同步数据有两种方式： （1）server写数据时，先将数据写入mysql，然后写入本地文件，写入完成后发送一个HTTP请求给集群中的其他server，其他server收到请求，从mysql中dump刚刚写入的数据至本地文件。 （2）server启动后会启动一个定时任务，定时从mysql中dump所有数据至本地文件。 2.2.client获取server地址server地址存储在一台具有域名的机器上的HTTP server中，我们称它为地址服务器 2.3.client主动获取数据client调用getAvailableConfigInfomation()， 即可获取一份最新的可用的配置数据，获取过程实际上是拼接http url，使用http-client调用http method的过程。 为了避免短时间内大量的获取数据请求发向server，client端实现了一个带有过期时间的缓存，client将本次获取到的数据保存在缓存中，在过期时间内的所有请求，都返回缓存内的数据，不向server发出请求。 2.4.client运行中感知数据变化这个特性是通过比较client和server的数据的MD5值实现的。 server端：server在启动时，会将所有数据的MD5加载到内存中（MD5根据某算法得出，保证数据内容不同，MD5不同，MD5存储在mysql中），数据更新时，会更新内存中对应的MD5 client端：client在启动并第一次获取数据后，会将数据的MD5保存在内存中，并且在启动时会启动一个定时任务，定时去server检查数据是否变化。每次检查时，client将MD5传给server，server比较传来的MD5和自身内存中的MD5是否相同； 如果相同，说明数据没变，返回一个标示数据不变的字符串给client； 如果不同，说明数据变了，返回变化数据的dataId和group给client. client收到变化数据的dataId和group，再去server请求一次数据，拿回数据后回调监听器。 3.diamond容灾机制3.1.server存储数据的方式server存储数据是“数据库 + 本地文件”的方式 3.2.server可以是一个集群集群中的一台server不可用了，client发现后可以自动切换到其他server上进行访问，自动切换在client内部实现 3.3.client保存snapshotclient每次从server获取到数据后，都会将数据保存在本地文件系统，diamond称之为snapshot，即数据快照。当client下次启动发现在超时时间内所有server均不可用（可能是网络故障），它会使用snapshot中的数据快照进行启动。 3.4.client与server可以完全分离client可以和server完全分离，单独使用，diamond定义了一个“容灾目录”的概念，client在启动时会创建这个目录，每次主动获取数据（即调用getAvailableConfigInfomation()方法），都会优先从“容灾目录”获取数据，如果client按照一个固定的规则，手动配置，在“容灾目录”下配置了需要的数据，那么client直接获取到数据返回，不再通过网络从diamond-server获取数据。同样的，在每次轮询时，都会优先轮询“容灾目录”，如果发现配置还存在于其中，则不再向server发出轮询请求。 以上的情形， 会持续到“容灾目录”的配置数据被删除为止。 根据以上的容灾机制，我们可以总结一下diamond整个系统完全不可用的条件： 1、mysql数据库不可用。 2、所有diamond-server均不可用。 3、client主动删除了snapshot本地磁盘文件。 4、client没有备份配置数据，导致其不能配置“容灾目录”。 同时满足以上4个条件的概率，在生产环境中是极小的。]]></content>
      <categories>
        <category>分布式配置</category>
      </categories>
      <tags>
        <tag>diamond</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nacos分布式配置]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%2Fnacos%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.实时更新流程 2.客户端操作每次都靠客户端去发请求，询问服务端我所关注的配置项有没有发生变更，那请求的间隔改设置为多少才合适呢？ 如果间隔时间设置的太长的话有可能无法及时获取服务端的变更，如果间隔时间设置的太短的话，那么频繁的请求对于服务端来说无疑也是一种负担。 所以最好的方式是客户端每隔一段长度适中的时间去服务端请求，而在这期间如果配置发生变更，服务端能够主动将变更后的结果推送给客户端，这样既能保证客户端能够实时感知到配置的变化，也降低了服务端的压力。 2.1.客户端长轮询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class LongPollingRunnable implements Runnable &#123; private int taskId; public LongPollingRunnable(int taskId) &#123; this.taskId = taskId; &#125; @Override public void run() &#123; List&lt;CacheData&gt; cacheDatas = new ArrayList&lt;CacheData&gt;(); List&lt;String&gt; inInitializingCacheList = new ArrayList&lt;String&gt;(); try &#123; // check failover config for (CacheData cacheData : cacheMap.get().values()) &#123; if (cacheData.getTaskId() == taskId) &#123; cacheDatas.add(cacheData); try &#123; //检查容灾目录配置的文件是否有变化（新增、修改、删除） checkLocalConfig(cacheData); if (cacheData.isUseLocalConfigInfo()) &#123; //其中（新增和修改是需要回调客户端监听器的） cacheData.checkListenerMd5(); &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125; //检查服务端数据是否有变化 List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList); for (String groupKey : changedGroupKeys) &#123; String[] key = GroupKey.parseKey(groupKey); String dataId = key[0]; String group = key[1]; String tenant = null; if (key.length == 3) &#123; tenant = key[2]; &#125; try &#123; //每个变化后的数据从服务端获取数据，通过dataid和groupid String content = getServerConfig(dataId, group, tenant, 3000L); CacheData cache = cacheMap.get().get(GroupKey.getKeyTenant(dataId, group, tenant)); cache.setContent(content); &#125; catch (NacosException ioe) &#123; &#125; &#125; for (CacheData cacheData : cacheDatas) &#123; if (!cacheData.isInitializing() || inInitializingCacheList .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123; //回调监听器 cacheData.checkListenerMd5(); &#125; &#125; executorService.execute(this); &#125; catch (Throwable e) &#123; &#125; &#125;&#125; 2.2.Server获取值变化了的DataID列表123456789101112131415161718192021List&lt;String&gt; checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws IOException &#123; List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString); List&lt;String&gt; headers = new ArrayList&lt;String&gt;(2); headers.add("Long-Pulling-Timeout"); headers.add("" + timeout); // told server do not hang me up if new initializing cacheData added in if (isInitializingCacheList) &#123; headers.add("Long-Pulling-Timeout-No-Hangup"); headers.add("true"); &#125; ... //timeout http超时时间 ,请求服务端数据 HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + "/listener", headers, params, agent.getEncode(), timeout); &#125; return Collections.emptyList();&#125; 3.服务端操作3.1.server提供的http服务比较md5值 123456789101112131415161718@PostMapping("/listener")public void listener(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", true); String probeModify = request.getParameter("Listening-Configs"); probeModify = URLDecoder.decode(probeModify, Constants.ENCODE); Map&lt;String, String&gt; clientMd5Map; try &#123; //解析client传入的参数 clientMd5Map = MD5Util.getClientMd5Map(probeModify); &#125; catch (Throwable e) &#123; &#125; // do long-polling //长轮询操作 inner.doPollingConfig(request, response, clientMd5Map, probeModify.length());&#125; 12345678910public String doPollingConfig(HttpServletRequest request, HttpServletResponse response, Map&lt;String, String&gt; clientMd5Map, int probeRequestSize) throws IOException &#123; // 长轮询 ,加入ClientLongPolling到alls队列 if (LongPollingService.isSupportLongPolling(request)) &#123; longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize); return HttpServletResponse.SC_OK + ""; &#125;&#125; 3.2.ClientLongPolling12345678910111213141516171819202122232425262728293031323334353637383940414243class ClientLongPolling implements Runnable &#123; @Override public void run() &#123; //正常任务执行逻辑（数据没有修改的情况下），每隔29.5秒检查一次 asyncTimeoutFuture = scheduler.schedule(new Runnable() &#123; @Override public void run() &#123; try &#123; /** * 删除订阅关系 */ allSubs.remove(ClientLongPolling.this); if (isFixedPolling()) &#123; //得到变化后到数据 List&lt;String&gt; changedGroups = MD5Util.compareMd5( (HttpServletRequest)asyncContext.getRequest(), (HttpServletResponse)asyncContext.getResponse(), clientMd5Map); if (changedGroups.size() &gt; 0) &#123; //发送结果 sendResponse(changedGroups); &#125; else &#123; sendResponse(null); &#125; &#125; &#125; &#125;, timeoutTime, TimeUnit.MILLISECONDS); //队列加入定时任务 allSubs.add(this); &#125; void sendResponse(List&lt;String&gt; changedGroups) &#123; /** * 取消超时任务 */ if (null != asyncTimeoutFuture) &#123; asyncTimeoutFuture.cancel(false); &#125; generateResponse(changedGroups); &#125; 3.3.数据变更逻辑1234567ConfigController.java// @PostMapping public Boolean publishConfig()&#123; persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, false); //发布事件 EventDispatcher.fireEvent(new ConfigDataChangeEvent(false, dataId, group, tenant, time.getTime()));&#125; 3.3.1.通知集群中其他服务器123456789101112131415161718192021222324252627282930class AsyncTask implements Runnable &#123; private void executeAsyncInvoke() &#123; while (!queue.isEmpty()) &#123; NotifySingleTask task = queue.poll(); String targetIp = task.getTargetIP(); if (serverListService.getServerList().contains( targetIp)) &#123; // 启动健康检查且有不监控的ip则直接把放到通知队列，否则通知 if (serverListService.isHealthCheck() &amp;&amp; ServerListService.getServerListUnhealth().contains(targetIp)) &#123; // target ip 不健康，则放入通知列表中 ConfigTraceService.logNotifyEvent(task.getDataId(), task.getGroup(), task.getTenant(), null, task.getLastModified(), LOCAL_IP, ConfigTraceService.NOTIFY_EVENT_UNHEALTH, 0, task.target); // get delay time and set fail count to the task asyncTaskExecute(task); &#125; else &#123; HttpGet request = new HttpGet(task.url); request.setHeader(NotifyService.NOTIFY_HEADER_LAST_MODIFIED, String.valueOf(task.getLastModified())); request.setHeader(NotifyService.NOTIFY_HEADER_OP_HANDLE_IP, LOCAL_IP); if (task.isBeta) &#123; request.setHeader("isBeta", "true"); &#125; httpclient.execute(request, new AsyncNotifyCallBack(httpclient, task)); &#125; &#125; &#125; &#125;&#125; 3.3.2.通知调用客户端12345678910111213141516171819class DataChangeTask implements Runnable &#123; @Override public void run() &#123; try &#123; ... //遍历队列中所有ClientLongPolling，如果groupKey相等则进行通知操作 for (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123; ClientLongPolling clientSub = iter.next(); if (clientSub.clientMd5Map.containsKey(groupKey)) &#123; ... iter.remove(); // 删除订阅关系 //返回结果给调用客户端 clientSub.sendResponse(Arrays.asList(groupKey)); &#125; &#125; &#125; catch (Throwable t) &#123; &#125; &#125; 4.结论 1.Nacos 客户端会循环请求服务端变更的数据，并且超时时间设置为30s，当配置发生变化时，请求的响应会立即返回，否则会一直等到 29.5s+ 之后再返回响应 2.Nacos 客户端能够实时感知到服务端配置发生了变化。 3.实时感知是建立在客户端拉和服务端“推”的基础上，但是这里的服务端“推”需要打上引号，因为服务端和客户端直接本质上还是通过 http 进行数据通讯的，之所以有“推”的感觉，是因为服务端主动将变更后的数据通过 http 的 response 对象提前写入了。]]></content>
      <categories>
        <category>分布式配置</category>
      </categories>
      <tags>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁(Redisson)]]></title>
    <url>%2F2019%2F11%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2FRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[1.使用方式1234RLock lock = redisson.getLock("myLock");// 最常见的使用方法lock.lock();lock.unlock(); 2.底层实现分布式锁原理 流程 问题 最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。 接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。 所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。 解决 red-lock算法，原理是对所有节点都加锁，多数通过则成功加锁，否则失败！ 如果第一个请求加锁，多数节点通过加锁成功，各节点保存加锁成功信息； 这时节点挂掉，第二个请求来了，请求加锁，多数节点认为锁已经存在不同意加锁，所以加锁失败，只有等待ex失效再次加锁]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2019%2F11%2F01%2Fjava-keyword%2Fvolatile%2F</url>
    <content type="text"><![CDATA[1.可见性对一个变量加了volatile关键字修饰之后，只要一个线程修改了这个变量的值，立马强制刷回主内存。 接着强制过期其他线程的本地工作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！ 这样就保证，任何一个线程修改了变量值，其他线程立马就可以看见了！ 2.有序性(禁止指令重排优化)先了解一个概念，内存屏障(Memory Barrier）。内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。 Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。 总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL，如下： 1234567891011121314151617public class DoubleCheckLock &#123; private static DoubleCheckLock instance; private DoubleCheckLock()&#123;&#125; public static DoubleCheckLock getInstance()&#123; //第一次检测 if (instance==null)&#123; //同步 synchronized (DoubleCheckLock.class)&#123; if (instance == null)&#123; //多线程环境下可能会出现问题的地方 instance = new DoubleCheckLock(); &#125; &#125; &#125; return instance; &#125;&#125; 正常逻辑 123memory = allocate(); //1.分配对象内存空间instance(memory); //2.初始化对象instance = memory; //3.设置instance指向刚分配的内存地址，此时instance！=null 由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。 异常逻辑 123memory = allocate(); //1.分配对象内存空间instance = memory; //3.设置instance指向刚分配的内存地址,此时instance!=null,但对象还没有初始化完成！instance(memory); //2.初始化对象 所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。 12//禁止指令重排优化private volatile static DoubleCheckLock instance; 3.原子性但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，volatile是不负责解决这个问题的，也就是不负责解决原子性问题！ 原子性问题，得依赖synchronized、ReentrantLock等加锁机制来解决。]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AQS]]></title>
    <url>%2F2019%2F11%2F01%2Fjava-keyword%2FAQS%2F</url>
    <content type="text"><![CDATA[核心思想 用原子操作来同步状态 加锁线程变量=null，通过（阻塞或者唤醒一个线程）来修改加锁线程标记 内部应该维护一个队列 流程]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[synchronized]]></title>
    <url>%2F2019%2F11%2F01%2Fjava-keyword%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[1.使用方式 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁 2.双重校验锁1234567891011121314151617public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 3.底层原理① synchronized 同步语句块的情况 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println("synchronized 代码块"); &#125; &#125;&#125; 转换为字节码 12345678910111213141516171819202122public void method();descriptor: ()Vflags: ACC_PUBLICCode:stack=2, locals=3, args_size=10: aload_01: dup2: astore_13: monitorenter4: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;7: ldc #3 // String synchronized 代码块9: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V12: aload_113: monitorexit14: goto 2217: astore_218: aload_119: monitorexit20: aload_221: athrow22: returnException table: synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 ② synchronized 修饰方法的的情况 12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println("synchronized 方法"); &#125;&#125; 转换为字节码 123456789101112public synchronized void method();descriptor: ()Vflags: ACC_PUBLIC, ACC_SYNCHRONIZEDCode:stack=2, locals=1, args_size=10: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;3: ldc #3 // String synchronized 方法5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V8: returnLineNumberTable:line 5: 0line 6: 8 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 4.JDK1.6 之后的synchronized 关键字底层做了哪些优化JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、重量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 自旋锁和自适应自旋 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名.自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。 另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。 锁消除 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。 锁粗化 原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。 5.Synchronized和ReenTrantLock 的区别不同点 synchronized 竞争锁时会一直等待；ReentrantLock 可以尝试获取锁，并得到获取结果 synchronized 获取锁无法设置超时；ReentrantLock 可以设置获取锁的超时时间 synchronized 无法实现公平锁；ReentrantLock 可以满足公平锁，即先等待先获取到锁 synchronized 控制等待和唤醒需要结合加锁对象的 wait() 和 notify()、notifyAll()；ReentrantLock 控制等待和唤醒需要结合 Condition 的 await() 和 signal()、signalAll() 方法 synchronized 是 JVM 层面实现的；ReentrantLock 是 JDK 代码层面实现 synchronized 在加锁代码块执行完或者出现异常，自动释放锁；ReentrantLock 不会自动释放锁，需要在 finally{} 代码块显示释放 相同点 协调多线程对共享对象、变量的访问 可重入，同一线程可以多次获得同一个锁 都保证了可见性和互斥性 6.synchronized和 volatile的区别 volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 7.sleep() 与 wait()的比较​ 1. wait只能在同步（synchronize）环境中被调用，而sleep不需要​ 2. wait方法在进入wait状态的时候会释放对象的锁，但是sleep方法不会​ 3. wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CAS]]></title>
    <url>%2F2019%2F11%2F01%2Fjava-keyword%2FCAS%2F</url>
    <content type="text"><![CDATA[CAS基本原理全称是：Compare and Set，也就是先比较再设置的意思，Atomic原子类底层用的不是传统意义的锁机制，而是无锁化的CAS机制，通过CAS机制保证多线程修改一个数值的安全性：先获取一个值，然后发起CAS，比较这个值被人改过没？如果没有，就更改值！这个CAS是原子的，别人不会打断你！ 操作流程 可能存在问题 但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。 这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。 在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。 LongAdderJava8优化：他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！ 在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。 接着如果发现并发更新的线程数量过多，就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。 而且他内部实现了自动分段迁移的机制，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。 这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。 最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。 AtomicInteger类常用方法1234567public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 AtomicInteger底层实现AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 1234567891011private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value;]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2019%2F11%2F01%2Fjava-keyword%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal是用来解决什么问题的？ 如何使用ThreadLocal？ ThreadLocal的实现原理是什么？ 可否举几个实际项目中使用ThreadLocal的案例？ 1.解决什么问题线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每个线程创建一个单独的变量副本，每个线程都可以改变自己的变量副本而不影响其它线程所对应的副本。 Synchronized用于线程间的数据共享，以时间换空间思想； ThreadLocal用于线程间的数据隔离，以空间换时间思想 2.如何使用ThreadLocal1234567891011121314151617181920212223242526272829303132public class ThreadLocalTest &#123; private static final ThreadLocal&lt;ThreadLocalTest&gt; LOCAL = new ThreadLocal&lt;ThreadLocalTest&gt;(); private String name; private ThreadLocalTest(String name) &#123; this.name = name; &#125; public static void main(String[] args) &#123; //线程1 new Thread(()-&gt;&#123; LOCAL.set(new ThreadLocalTest("aa")); System.out.println(LOCAL.get()); &#125;).start(); //线程2 new Thread(()-&gt;&#123; LOCAL.set(new ThreadLocalTest("bb")); System.out.println(LOCAL.get()); &#125;).start(); //线程3 main线程 LOCAL.set(new ThreadLocalTest("cc")); System.out.println(LOCAL.get()); &#125; @Override public String toString() &#123; return this.name; &#125;&#125;//输出aaccbb 3.ThreadLocal实现原理 1234567publicclass Thread implements Runnable &#123; ... //每个线程都自带一个threadLocals变量 ThreadLocal.ThreadLocalMap threadLocals = null; ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ThreadLocal&lt;T&gt; &#123; -------------------ThreadLocal对外暴露的方法，内部操作还是基于ThreadLocalMap------------------- //对外代理ThreadLocalMap来操作set方法 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //判断该线程是否已经创建了ThreadLocalMap if (map != null) map.set(this, value); else createMap(t, value); &#125; //对外代理ThreadLocalMap来操作remove方法 public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); //判断该线程是否已经创建了ThreadLocalMap if (m != null) m.remove(this); &#125; //对外代理ThreadLocalMap来操作get方法 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //判断该线程是否已经创建了ThreadLocalMap if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); ///能够Entry则返回e.value if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //如果不能获取设置默认值 return setInitialValue(); &#125; ---------------------查询和创建ThreadLocalMap类------------------------------------ //返回该线程对应的【ThreadLocalMap】 ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; //创建该线程对应的【ThreadLocalMap】 void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; -----------------------ThreadLocalMap静态内部类---------------------------------- static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; //设置 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; ... &#125; //删除 private void remove(ThreadLocal&lt;?&gt; key) &#123; ... &#125; //查询 private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; ... &#125; &#125; ---------------------------------------------------------&#125; 每个线程的本地变量不是存放到ThreadLocal实例里面的，而是存放到调用线程的threadLocals变量里面 ThreadLocal就是一个工具壳，它通过set方法把value值放入调用线程的threadLocals里面存放起来，当调用线程调用它的get方法时再从当前线程的threadLocals变量里面拿出来使用。 4.使用ThreadLocal的案例在dubbo中会先使用请求参数判断当前线程是否刚刚发起过同样参数的调用——这个调用会使ThreadLocalCache保存起来 12345678910111213141516171819public class ThreadLocalCache implements Cache &#123; private final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; store; public ThreadLocalCache(URL url) &#123; this.store = new ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;() &#123; @Override protected Map&lt;Object, Object&gt; initialValue() &#123; return new HashMap&lt;Object, Object&gt;(); &#125; &#125;; &#125; @Override public void put(Object key, Object value) &#123; store.get().put(key, value); &#125; @Override public Object get(Object key) &#123; return store.get().get(key); &#125;&#125; 1234567891011121314151617181920public abstract class AbstractCacheFactory implements CacheFactory &#123; //全局缓存,通过key=Cache【 String key = url.toFullString();】 //在Cache缓存中存储有 key = 同一个请求的返回值 //【String key = StringUtils.toArgumentString(invocation.getArguments());】 private final ConcurrentMap&lt;String, Cache&gt; caches = new ConcurrentHashMap&lt;String, Cache&gt;(); @Override public Cache getCache(URL url, Invocation invocation) &#123; url = url.addParameter(Constants.METHOD_KEY, invocation.getMethodName()); String key = url.toFullString(); Cache cache = caches.get(key); if (cache == null) &#123; caches.put(key, createCache(url)); cache = caches.get(key); &#125; return cache; &#125; protected abstract Cache createCache(URL url);&#125; 最常见的ThreadLocal使用场景为 ：用来解决 数据库连接、Session管理等。 5.ThreadLocal导致的内存泄漏ThreadLocalMap的key为ThreadLocal实例，他是一个弱引用，我们知道弱引用有利于GC的回收，当key == null时，GC就会回收这部分空间，但value不一定能被回收，因为他和Current Thread之间还存在一个强引用的关系。由于这个强引用的关系，会导致value无法回收，如果线程对象不消除这个强引用的关系，就可能会出现OOM。有些时候，我们调用ThreadLocalMap的remove()方法进行显式处理。 6.ThreadLocalRandom应用案例java.util.Random是应用广泛的随机数生成工具类。根据JDK介绍，是线程安全的。 单线程下的Random实现： while循环中的CAS操作会保证只有一个线程可以更新老的种子为新的，失败的线程会通过循环重新获取更新后的种子作为当前种子去计算老的种子，保证了随机数的随机性 123456789protected int next(int bits) &#123; long oldseed, nextseed; AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) &amp; mask; &#125; while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed &gt;&gt;&gt; (48 - bits));&#125; 多线程下使用单个Random实例生成随机数，多个线程同时计算随机数计算新种子的时候，它们会竞争同一个原子变量的更新操作，因为原子变量的更新是CAS操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这是会降低并发性能，于是ThreadLocalRandom应运而生。 123456public class ThreadLocalRandom extends Random &#123; ... private static final ThreadLocal&lt;Double&gt; nextLocalGaussian = new ThreadLocal&lt;Double&gt;(); ...&#125;]]></content>
      <categories>
        <category>Java关键字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 削峰填谷]]></title>
    <url>%2F2019%2F10%2F19%2Fsentinel%2FSentinel%20%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[1.整体流程 2.源码分析RateLimiterController 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic boolean canPass(Node node, int acquireCount) &#123; // 按照斜率来计算计划中应该什么时候通过 long currentTime = TimeUtil.currentTimeMillis(); long costTime = Math.round(1.0 * (acquireCount) / count * 1000); //期待时间 long expectedTime = costTime + latestPassedTime.get(); if (expectedTime &lt;= currentTime) &#123; //这里会有冲突,然而冲突就冲突吧. latestPassedTime.set(currentTime); return true; &#125; else &#123; // 计算自己需要的等待时间 long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis(); //大于最大等待时间 if (waitTime &gt;= maxQueueingTimeMs) &#123; return false; &#125; else &#123; long oldTime = latestPassedTime.addAndGet(costTime); try &#123; waitTime = oldTime - TimeUtil.currentTimeMillis(); //二次判断 大于 最大等待时间 if (waitTime &gt;= maxQueueingTimeMs) &#123; latestPassedTime.addAndGet(-costTime); return false; &#125; //线程休眠 Thread.sleep(waitTime); return true; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>分布式限流熔断降级</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 滑动窗口]]></title>
    <url>%2F2019%2F10%2F18%2Fsentinel%2FSentinel%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1.核心思想 定义每个时间窗口长度windowLength=500，定义样本数组大小arrayLength=2 首先计算当前时间所对应的数组下标位置，计算方式 ​ long time = System.currentTimeMillis();//当前时间 ​ long timeId = time/windowLength; ​ int idx = (int)(timeId % arrayLength); 然后计算当前时间所对应的窗口开始时间，计算方式 long currentWindowStart = time - time % windowLength; 2.调用流程graph LR A(计算当前时间所对应的数组下标位置) -->B(计算当前时间所对应的窗口开始时间) B(计算当前时间所对应的窗口开始时间) -->D{根据下标获取当前窗口} D -->|可以| E(获取当前窗口开始时间) E(获取当前窗口开始时间) --> F{两者窗口开始时间比较} F -->|相等|G(返回当前窗口) F -->|新大于老|H(滑动窗口并重置) D -->|不可以| I(创建新窗口) 3.窗口时间轴变化 第一次：当前时间戳=49， 索引=0，窗口开始时间=0 =&gt;不存在，创建窗口 第二次：当前时间戳=729，索引=1，窗口开始时间=500 =&gt;不存在，创建窗口 第三次：当前时间戳=1028，索引=0，新窗口开始时间=1000， 根据索引=0 获取原窗口开始时间=0， ​ 则新开始时间&gt;原开始时间，需要将原窗口开始时间置为1000，同时将原有值清0 第四次：当前时间戳=1980，索引=1，新窗口开始时间=1500， 根据索引=1 获取原窗口开始时间=500， ​ 则新开始时间&gt;原开始时间，需要将原窗口开始时间置为1500，同时将原有值清0 4.源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public WindowWrap&lt;T&gt; currentWindow(long time) &#123; long timeId = time / windowLengthInMs; // 计算当前时间所对应的数组下标位置 int idx = (int)(timeId % array.length()); // 计算当前时间所对应的窗口开始时间 time = time - time % windowLengthInMs; while (true) &#123; WindowWrap&lt;T&gt; old = array.get(idx);//根据下标获取当前窗口 if (old == null) &#123; WindowWrap&lt;T&gt; window = new WindowWrap&lt;T&gt;(windowLengthInMs, time, newEmptyBucket()); if (array.compareAndSet(idx, null, window)) &#123; return window; &#125; else &#123; Thread.yield(); &#125; &#125; else if (time == old.windowStart()) &#123; //相等，直接返回 return old; &#125; else if (time &gt; old.windowStart()) &#123; //新值大于旧值 ... // 滑动窗口并重置 return resetWindowTo(old, time); // ... &#125; &#125;&#125;@Overrideprotected WindowWrap&lt;MetricBucket&gt; resetWindowTo(WindowWrap&lt;MetricBucket&gt; w, long startTime) &#123; //重置窗口开始时间 w.resetTo(startTime); //清空值 w.value().reset(); return w;&#125;//重置窗口开始时间public WindowWrap&lt;T&gt; resetTo(long startTime) &#123; this.windowStart = startTime; return this;&#125;//清空值public MetricBucket reset() &#123; pass.reset(); block.reset(); exception.reset(); rt.reset(); success.reset(); initMinRt(); return this;&#125; 5.测试代码1234567891011121314151617181920212223242526272829303132333435363738394041public class WindowLeapArrayTest &#123; public static void main(String[] args) throws InterruptedException&#123; int windowLength = 500; int arrayLength = 2; calculate(windowLength,arrayLength); Thread.sleep(100); calculate(windowLength,arrayLength); Thread.sleep(200); calculate(windowLength,arrayLength); Thread.sleep(200); calculate(windowLength,arrayLength); Thread.sleep(500); calculate(windowLength,arrayLength); Thread.sleep(500); calculate(windowLength,arrayLength); Thread.sleep(500); calculate(windowLength,arrayLength); Thread.sleep(500); calculate(windowLength,arrayLength); Thread.sleep(500); calculate(windowLength,arrayLength); &#125; private static void calculate(int windowLength,int arrayLength)&#123; long time = System.currentTimeMillis(); long timeId = time/windowLength; long currentWindowStart = time - time % windowLength; int idx = (int)(timeId % arrayLength); System.out.println("time="+time+",currentWindowStart="+currentWindowStart+",timeId="+timeId+",idx="+idx); &#125;&#125;]]></content>
      <categories>
        <category>分布式限流熔断降级</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 核心详解]]></title>
    <url>%2F2019%2F10%2F16%2Fsentinel%2FSentinel%20%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.整体流程 2.Slot详解2.1.NodeSelectorSlot2.1.1.Context不同,只考虑Resource相同情况 第一种场景：Context name = “entrance1” origin = “appA” 123456ContextUtil.enter("entrance1", "appA");Entry nodeA = SphU.entry("nodeA");if (nodeA != null) &#123; nodeA.exit();&#125;ContextUtil.exit(); 转换为 12345678910 machine-root / / EntranceNode1 / / DefaultNode(nodeA) / /ClusterNode(nodeA); 第二种场景：Context name = “entrance1” origin = “appA” name = “entrance2” origin = “appA” 12345678910111213ContextUtil.enter("entrance1", "appA");Entry nodeA = SphU.entry("nodeA");if (nodeA != null) &#123; nodeA.exit();&#125;ContextUtil.exit();ContextUtil.enter("entrance2", "appA");nodeA = SphU.entry("nodeA");if (nodeA != null) &#123; nodeA.exit();&#125;ContextUtil.exit(); 转换为 12345678910 machine-root / \ / \ EntranceNode1 EntranceNode2 / \ / \DefaultNode(nodeA) DefaultNode(nodeA) \ / \ / ClusterNode(nodeA) 3.1.2.Context相同,Resource相同和不同 Resource相同情况 12Entry nodeA = SphU.entry("nodeA");Entry nodeA = SphU.entry("nodeA"); Resource不相同情况 12Entry nodeA = SphU.entry("nodeA");Entry nodeB = SphU.entry("nodeB"); 2.2.FlowSlot2.2.1.限流阀值类型grade 线程数限制 QPS限制 2.2.2.流控调用来源limitApp 默认限制来源 default (不区分调用来源) 其他限制来源 other (不等于default和orgin的来源) 指定限制来源 orgin 2.2.3.流控模式strategy 直接限流 direct (当前节点的数据) 关联限流 relate (对应关联节点的数据) 链路限流 chain (根据链路入口节点信息) 2.2.4.流控效果controlBehavior 直接拒绝 default 冷启动 WarmUp grade = QPS 匀速器RateLimiter grade = QPS 2.3.DegradSlot2.3.1.降级模式grade 根据RT降级 根据异常比例降级 根据异常总数降级 2.3.2.降级时间 中断时间timeWindow]]></content>
      <categories>
        <category>分布式限流熔断降级</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sentinel 基本概念]]></title>
    <url>%2F2019%2F10%2F15%2Fsentinel%2FSentinel%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1.基本概念ResourceStringResourceWrapper 使用string来标识一个资源 MethodResouceWrapper 使用一个函数签名来标识一个资源 Node DefaultNode和ClusterNode区别 DefaultNode：保存着某个resource在某个context中的实时指标，每个DefaultNode都指向一个ClusterNode ClusterNode：保存着某个resource在所有的context中实时指标的总和，同样的resource会共享同一个ClusterNode，不管他在哪个context中 Context上下文是用来保存当前调用的元数据，存储在ThreadLocal中，它包含了几个信息： EntranceNode 整个调用树的根节点，即入口 Entry 当前的调用点 Node 关联到当前调用点的统计信息 Origin 通常用来标识调用方，这在我们需要按照调用方来区分流控策略的时候会非常有用 每当我们调用SphU.entry()或者 SphO.entry()获取访问资源许可的时候都需要当前线程处在某个context中，如果我们没有显式调用ContextUtil.enter()，默认会使用Default context。如果我们在一个上下文中多次调用SphU.entry()来获取多个资源，一个调用树就会被创建出来 EntryTypeEntryType 说的是这次请求的流量类型，共有两种类型：IN 和 OUT 。 IN：是指进入我们系统的入口流量，比如 http 请求或者是其他的 rpc 之类的请求。 OUT：是指我们系统调用其他第三方服务的出口流量。 入口、出口流量只有在配置了系统规则时才有效。 设置Type 为 IN 是为了统计整个系统的流量水平，防止系统被打垮，用以自我保护的一种方式。 Slot NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级； ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据； StatisticsSlot 则用于记录，统计不同维度的 runtime 信息； SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量； AuthoritySlot 则根据黑白名单，来做黑白名单控制； FlowSlot 则用于根据预设的限流规则，以及前面 slot 统计的状态，来进行限流； DegradeSlot 则通过统计信息，以及预设的规则，来做熔断降级；]]></content>
      <categories>
        <category>分布式限流熔断降级</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 自动装配]]></title>
    <url>%2F2019%2F10%2F12%2Fdubbo%2FDubbo%20%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.整合Spring使用方式1.1.服务提供方1.Service注解暴露服务 1234567@Servicepublic class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; 2.增加配置 1234dubbo.application.name=dubbo-demo-annotation-providerdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.protocol.name=dubbodubbo.protocol.port=20880 3.制定Spring扫描路径 123456@Configuration@EnableDubbo(scanBasePackages = "org.apache.dubbo.demo.provider")@PropertySource("classpath:/spring/dubbo-provider.properties")class ProviderConfiguration &#123;&#125; 4.启动服务暴露者 1234public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class); //System.in.read();&#125; 1.2.服务消费方1.Reference注解引用服务 1234567891011@Componentpublic class DemoServiceComponent implements DemoService &#123; @Reference private DemoService demoService; @Override public String sayHello(String name) &#123; return demoService.sayHello(name); &#125;&#125; 2.增加配置 12dubbo.application.name=dubbo-demo-annotation-consumerdubbo.registry.address=zookeeper://10.0.10.21:15311 3.指定Spring扫描路径 1234567@Configuration@EnableDubbo(scanBasePackages = "org.apache.dubbo.demo.consumer.comp")@PropertySource("classpath:/spring/dubbo-consumer.properties")@ComponentScan(value = &#123;"org.apache.dubbo.demo.consumer.comp"&#125;)static class ConsumerConfiguration &#123;&#125; 4.启动服务消费者 123456public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); DemoService service = context.getBean("demoServiceComponent", DemoServiceComponent.class); String hello = service.sayHello("world"); System.out.println("==================" + hello);&#125; 2.源码分析2.1.注解@EnableDubbo@EnableDubbo注解 = @DubboComponentScan注解 + @EnableDubboConfig注解 1234567891011121314@EnableDubboConfig@DubboComponentScanpublic @interface EnableDubbo &#123; @AliasFor(annotation = DubboComponentScan.class, attribute = "basePackages") String[] scanBasePackages() default &#123;&#125;; @AliasFor(annotation = DubboComponentScan.class, attribute = "basePackageClasses") Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; @AliasFor(annotation = EnableDubboConfig.class, attribute = "multiple") boolean multipleConfig() default true;&#125; 2.2.注解@EnableDubboConfig1234@Import(DubboConfigConfigurationRegistrar.class)public @interface EnableDubboConfig &#123; boolean multiple() default true;&#125; 123456789101112131415161718public class DubboConfigConfigurationRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AnnotationAttributes attributes = AnnotationAttributes.fromMap( importingClassMetadata.getAnnotationAttributes(EnableDubboConfig.class.getName())); boolean multiple = attributes.getBoolean("multiple"); // Single Config Bindings registerBeans(registry, DubboConfigConfiguration.Single.class); if (multiple) &#123; registerBeans(registry, DubboConfigConfiguration.Multiple.class); &#125; &#125;&#125; DubboConfigConfiguration 12345678910111213141516171819202122232425262728293031323334public class DubboConfigConfiguration &#123; /** * Single Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = "dubbo.application", type = ApplicationConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.module", type = ModuleConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.registry", type = RegistryConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.protocol", type = ProtocolConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.monitor", type = MonitorConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.provider", type = ProviderConfig.class), @EnableDubboConfigBinding(prefix = "dubbo.consumer", type = ConsumerConfig.class) &#125;) public static class Single &#123; &#125; /** * Multiple Dubbo &#123;@link AbstractConfig Config&#125; Bean Binding */ @EnableDubboConfigBindings(&#123; @EnableDubboConfigBinding(prefix = "dubbo.applications", type = ApplicationConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.modules", type = ModuleConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.registries", type = RegistryConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.protocols", type = ProtocolConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.monitors", type = MonitorConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.providers", type = ProviderConfig.class, multiple = true), @EnableDubboConfigBinding(prefix = "dubbo.consumers", type = ConsumerConfig.class, multiple = true) &#125;) public static class Multiple &#123; &#125;&#125; 2.3.注解@DubboComponentScan]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 服务暴露解析]]></title>
    <url>%2F2019%2F10%2F11%2Fdubbo%2FDubbo%20%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.整体流程图 2.详细流程分解2.1.Spring容器初始化调用ServiceBean123456789101112131415public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements ApplicationListener&lt;ContextRefreshedEvent&gt;&#123; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123; export(); &#125; &#125; @Override public void export() &#123; //执行父类export方法 super.export(); // Publish ServiceBeanExportedEvent 发布事件，扩展点 publishExportEvent(); &#125;&#125; 2.2.ServiceConfig执行export方法 首先会检查各种配置信息，填充各种属性，总之就是保证我在开始暴露服务之前，所有的东西都准备好了，并且是正确的。 加载所有的注册中心，因为我们暴露服务需要注册到注册中心中去。 根据配置的所有协议和注册中心url分别进行导出。 进行导出的时候，又是一波属性的获取设置检查等操作。 如果配置的不是remote，则做本地导出。 如果配置的不是local，则暴露为远程服务。 不管是本地还是远程服务暴露，首先都会获取Invoker。 获取完Invoker之后，转换成对外的Exporter，缓存起来。 初始化方法Protocol 1234567891011121314151617public class MyProtocol implements Protocol &#123; //导出 public Exporter export(Invoker arg0) throws RpcException &#123; URL url = arg0.getUrl(); String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol()); Protocol extension = (Protocol) ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName); return extension.export(arg0); &#125; //消费 public Invoker refer(java.lang.Class arg0, URL arg1) throws RpcException &#123; if (arg1 == null) throw new IllegalArgumentException("url == null"); URL url = arg1; String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol()); Protocol extension = (Protocol) ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName); return extension.refer(arg0, arg1); &#125;&#125; 初始化ProxyFactory 12345678910111213141516171819202122public class MyProxyFactory implements ProxyFactory &#123; public getProxy(Invoker arg0) throws RpcException &#123; URL url = arg0.getUrl(); String extName = url.getParameter("proxy", "javassist"); ProxyFactory extension = (ProxyFactory) ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName); return extension.getProxy(arg0); &#125; public getProxy(Invoker arg0, boolean arg1) throws RpcException &#123; URL url = arg0.getUrl(); String extName = url.getParameter("proxy", "javassist"); ProxyFactory extension = (ProxyFactory) ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName); return extension.getProxy(arg0, arg1); &#125; public Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, URL arg2) throws RpcException &#123; URL url = arg2; String extName = url.getParameter("proxy", "javassist"); ProxyFactory extension = (ProxyFactory) ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName); return extension.getInvoker(arg0, arg1, arg2); &#125;&#125; 导出开始… 123456789101112131415public synchronized void export() &#123; ...前置检查动作 //是否延迟暴露 if (delay != null &amp;&amp; delay &gt; 0) &#123; delayExportExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; doExport(); &#125; &#125;, delay, TimeUnit.MILLISECONDS); &#125; else &#123; //直接暴露 doExport(); &#125;&#125; 12345678910111213protected synchronized void doExport() &#123; //前置检查动作 doExportUrls(); ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref); ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);&#125;//具体导出URLprivate void doExportUrls() &#123; List&lt;URL&gt; registryURLs = loadRegistries(true); for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125;&#125; 12345678910111213141516171819202122232425262728293031private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; //初始URL： String scope = url.getParameter(Constants.SCOPE_KEY); // don't export when none is configured if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123; //本地暴露 if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; //远程暴露 if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123; if (registryURLs != null &amp;&amp; !registryURLs.isEmpty()) &#123; for (URL registryURL : registryURLs) &#123; //监控中心url URL monitorUrl = loadMonitor(registryURL); if (monitorUrl != null) &#123; url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString()); &#125; //ServiceConfig 通过代理 转换为 Invoker Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); //Invoker 转换为 Exporter Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); //加入缓存 exporters.add(exporter); &#125; &#125; &#125; &#125;&#125; 初始URL dubbo://10.200.182.56:20880/org.apache.dubbo.demo.DemoService? anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=10.200.182.56&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=48977&amp;side=provider&amp;timestamp=1568611822696 2.2.1.加载所有注册中心12345678910111213141516171819202122232425262728293031protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; !registries.isEmpty()) &#123; for (RegistryConfig config : registries) &#123; //从配置中获取注册地址 String address = config.getAddress(); if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; //从环境变量中获取注册地址 String sysaddress = System.getProperty("dubbo.registry.address"); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; if (address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //...添加map参数 List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); for (URL url : urls) &#123; url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); url = url.setProtocol(Constants.REGISTRY_PROTOCOL); if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList;&#125; 最终返回结果 [registry://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;pid=48612&amp;registry=zookeeper&amp;timestamp=1568601143093] 多个注册中心结果[] 2.2.2.本地暴露服务12345678910111213141516private void exportLocal(URL url) &#123; if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123; URL local = URL.valueOf(url.toFullString()) .setProtocol(Constants.LOCAL_PROTOCOL) .setHost(LOCALHOST) .setPort(0); StaticContext.getContext(Constants.SERVICE_IMPL_CLASS).put(url.getServiceKey(), getServiceClass(ref)); //这里的protocol = InjvmProtocol Exporter&lt;?&gt; exporter = protocol.export( //这里的proxyFactory = JavassistProxyFactory //ref = new 实现类 proxyFactory.getInvoker(ref, (Class) interfaceClass, local)); exporters.add(exporter); logger.info("Export dubbo service " + interfaceClass.getName() + " to local registry"); &#125;&#125; 本地暴露URL injvm://127.0.0.1/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=10.200.182.56&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=48977&amp;side=provider&amp;timestamp=1568611822696 2.2.3.远程暴露服务12345678910//ServiceConfig 通过代理 转换为 Invoker Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);//Invoker 转换为 ExporterExporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);//加入缓存exporters.add(exporter); registryURL格式为 registry://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;export=dubbo://10.200.182.56:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;bind.ip=10.200.182.56&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=48636&amp;side=provider&amp;timestamp=1568602364738&amp;pid=48636&amp;registry=nacos&amp;timestamp=1568602336799 2.2.3.1.使用JavassistProxyFactory获取Invoker1234567891011121314@Overridepublic &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; //封装Wrapper类 //手动生成该类 final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type); return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); &#125; &#125;;&#125; 生成后的类代码 123456789101112131415public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws InvocationTargetException &#123; org.apache.dubbo.demo.DemoService w; try &#123; w = ((org.apache.dubbo.demo.DemoService) $1); &#125; catch (Throwable e) &#123; throw new IllegalArgumentException(e); &#125; try &#123; if ("sayHello".equals($2) &amp;&amp; $3.length == 1) &#123; return ($w) w.sayHello((java.lang.String) $4[0]); &#125; &#125; catch (Throwable e) &#123; throw new java.lang.reflect.InvocationTargetException(e); &#125;&#125; 2.2.4.暴露远程服务时导出Invoker为ExporterInvoker导出为Exporter分为两种情况，第一种是Registry类型的Invoker，第二种是其他协议类型的Invoker，分开解析。 1Exporter&lt;?&gt; exporter = protocol.export(invoker); 调用过程 ProtocolListenerWrapper#export()-&gt;ProtocolFilterWrapper#export()-&gt;RegistryProtocol#export() 2.2.4.1.Registry类型的Invoker处理过程 经过两个不用做任何处理的Wrapper类，然后到达RegistryProtocol中。 通过具体的协议导出Invoker为Exporter。 注册服务到注册中心。 订阅注册中心的服务。 生成一个新的Exporter实例，将上面的Exporter进行引入，然后返回。 ProtocolFilterWrapper.export过程 123456789@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; //registry类型的Invoker，不需要做处理 if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; //非Registry类型的Invoker需要先构建调用链，然后再导出 return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));&#125; ProtocolListenerWrapper.export过程 12345678910@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; //registry类型的Invoker，不需要做处理 if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; //非Registry类型的Invoker，需要被监听器包装 return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class) .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));&#125; RegistryProtocol.export过程 RegistryProtocol负责注册服务到注册中心和向注册中心订阅服务 123456789101112131415161718192021222324252627282930313233@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123; //具体协议进行导出 final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker); //获取注册中心URL URL registryUrl = getRegistryUrl(originInvoker); //根据注册URL获取注册中心实例 final Registry registry = getRegistry(originInvoker); //注册到注册中心的URL final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker); //to judge to delay publish whether or not boolean register = registeredProviderUrl.getParameter("register", true); ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl); if (register) &#123; //注册中心中创建相对应的节点信息 register(registryUrl, registeredProviderUrl); ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); &#125; //订阅override数据，主要订阅configurators节点数据 final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl); final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker); overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener); registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener); //Ensure that a new exporter instance is returned every time export return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);&#125; 1. 获取注册中心registryUrl 12345678private URL getRegistryUrl(Invoker&lt;?&gt; originInvoker) &#123; URL registryUrl = originInvoker.getUrl(); if (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123; String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY); registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY); &#125; return registryUrl;&#125; 2.获取注册到注册中心的registeredProviderUrl 123456789101112private URL getRegisteredProviderUrl(final Invoker&lt;?&gt; originInvoker) &#123; URL providerUrl = getProviderUrl(originInvoker); //The address you see at the registry return providerUrl.removeParameters(getFilteredKeys(providerUrl)) .removeParameter(Constants.MONITOR_KEY) .removeParameter(Constants.BIND_IP_KEY) .removeParameter(Constants.BIND_PORT_KEY) .removeParameter(QOS_ENABLE) .removeParameter(QOS_PORT) .removeParameter(ACCEPT_FOREIGN_IP) .removeParameter(VALIDATION_KEY);&#125; 3.根据注册URL获取注册中心实例 12345private Registry getRegistry(final Invoker&lt;?&gt; originInvoker) &#123; URL registryUrl = getRegistryUrl(originInvoker); return registryFactory.getRegistry(registryUrl);&#125;//这里的registryFactory = ZookeeperRegistryFactory 4.AbstractRegistryFactory#getRegistry 12345678910111213141516@Overridepublic Registry getRegistry(URL url) &#123; url = url.setPath(RegistryService.class.getName()) .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName()) .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY); //zookeeper://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService LOCK.lock(); try &#123; //返回实例： new ZookeeperRegistry(url, zookeeperTransporter); registry = createRegistry(url); return registry; &#125; finally &#123; // Release the lock LOCK.unlock(); &#125;&#125; ZookeeperRegistry-&gt;FailbackRegistry-&gt;AbstractRegistry 5.new ZookeeperRegistry()过程 AbstractRegistry构造过程 123456789101112131415public AbstractRegistry(URL url) &#123; setUrl(url); // syncSaveFile 是否异步保存文件 syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false); String filename = url.getParameter(Constants.FILE_KEY, System.getProperty("user.home") + "/.dubbo/dubbo-registry-" + url.getParameter(Constants.APPLICATION_KEY) + "-" + url.getAddress() + ".cache"); File file = null; if (ConfigUtils.isNotEmpty(filename)) &#123; file = new File(filename); &#125; this.file = file; //加载文件中的属性 loadProperties(); //通知订阅 notify(url.getBackupUrls());&#125; FailbackRegistry构造过程 12345678910111213141516171819public FailbackRegistry(URL url) &#123; super(url); //重试时间，默认5000ms this.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD); //启动失败重试定时器 this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; // Check and connect to the registry try &#123; //重试方法由每个具体子类实现 //获取到注册失败的，然后尝试注册 retry(); &#125; catch (Throwable t) &#123; // Defensive fault tolerance &#125; &#125; &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);&#125; ZookeeperRegistry构造过程 12345678910111213141516171819202122232425public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123; super(url); if (url.isAnyHost()) &#123; throw new IllegalStateException("registry address == null"); &#125; String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123; group = Constants.PATH_SEPARATOR + group; &#125; this.root = group; //然后返回一个ZkClientZookeeperClient实例 zkClient = zookeeperTransporter.connect(url); zkClient.addStateListener(new StateListener() &#123; @Override public void stateChanged(int state) &#123; if (state == RECONNECTED) &#123; try &#123; recover(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; &#125;);&#125; 6.将url注册到注册中心 123456789@Overrideprotected void doRegister(URL url) &#123; try &#123; //创建节点，默认创建的节点是临时节点 zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true)); &#125; catch (Throwable e) &#123; ... &#125;&#125; URL地址 dubbo://10.200.182.56:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=48636&amp;side=provider&amp;timestamp=1568602364738 2.2.4.2.交给具体的协议进行服务暴露这里也就是非Registry类型的Invoker的导出过程。主要的步骤是将本地ip和20880端口打开，进行监听。最后包装成exporter返回。 ProtocolListenerWrapper#export()-&gt;ProtocolFilterWrapper#export()-&gt;DubboProtocol#export() 1234567///这里我们需要调用DubboProtocol的export方法private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker) &#123; final Invoker&lt;?&gt; invokerDelegete = new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker)); exporter = new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker); bounds.put(key, exporter); return exporter;&#125; 1.DubboProtocol#export() 12345678@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; URL url = invoker.getUrl(); ////根据URL绑定IP与端口，建立NIO框架的Server openServer(url); optimizeSerialization(url); return exporter;&#125; 2.ProtocolListenerWrapper#export() 123456789@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class) .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));&#125; 3.ProtocolFilterWrapper#export() 123456789@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123; return protocol.export(invoker); &#125; //其他具体协议类型的Invoker //先构建Filter链，然后再导出 return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));&#125; 123456789101112131415161718private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123; Invoker&lt;T&gt; last = invoker; //Filter链 List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); if (!filters.isEmpty()) &#123; for (int i = filters.size() - 1; i &gt;= 0; i--) &#123; final Filter filter = filters.get(i); final Invoker&lt;T&gt; next = last; last = new Invoker&lt;T&gt;() &#123; @Override public Result invoke(Invocation invocation) throws RpcException &#123; return filter.invoke(next, invocation); &#125; &#125;; &#125; &#125; return last;&#125;]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 服务消费解析]]></title>
    <url>%2F2019%2F10%2F09%2Fdubbo%2FDubbo%20%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.整体流程图 2.详细流程分解2.1.Spring容器中的ReferenceBean 服务消费者端对应的是ReferenceBean 实现了ApplicationContextAware接口，Spring会在Bean的实例化那一步回调setApplicationContext方法。 实现了InitializingBean接口，接着会回调afterPropertySet方法。 实现了FactoryBean接口，可以在后期获取bean的时候做一些操作，dubbo在这个时候做初始化。 实现了DisposableBean接口，会在bean销毁的时候调用destory方法。 123456public class ReferenceBean&lt;T&gt; extends ReferenceConfig&lt;T&gt; implements FactoryBean, ApplicationContextAware, InitializingBean, DisposableBean &#123; @Override public Object getObject() throws Exception &#123; return get(); &#125;&#125; 消费者的初始化是在ReferenceBean的init方法中执行,分为两种情况： reference标签中没有配置init属性，此时是延迟初始化的，也就是只有等到bean引用被注入到其他Bean中，或者调用getBean获取这个Bean的时候，才会初始化。比如在这里的例子里reference没有配置init属性，只有等到HelloService helloService = (HelloService) applicationContext.getBean(&quot;helloService&quot;);这句getBean的时候，才会开始调用init方法进行初始化。 reference标签中init属性配置为true，会立即进行初始化（也就是上面说到的实现了FactoryBean接口）。 2.2.ReferenceConfig#init()init()方法会先检查初始化所有的配置信息，然后调用ref = createProxy(map);创建代理，消费者最终得到的是服务的代理。初始化主要做的事情就是引用对应的远程服务，大概的步骤： 监听注册中心 连接服务提供者端进行服务引用 创建服务代理并返回 文档上关于Zookeeper作为注册中心时，服务消费者启动时要做的事情有： 订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址。并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址。 2.2.1.创建代理12345678910private T createProxy(Map&lt;String, String&gt; map) &#123; //1.判断是否是本地服务引用injvm //2.判断是否是点对点直连 //3.判断是否是通过注册中心连接 //4.最后是对服务的引用 //引用远程服务由Protocol的实现来处理 invoker = refprotocol.refer(interfaceClass, urls.get(0)); //最后返回服务代理 return (T) proxyFactory.getProxy(invoker);&#125; 这里的URL registry://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo-api-consumer&amp;dubbo=2.0.2&amp;pid=49336&amp;refer=application=dubbo-demo-api-consumer&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=49336&amp;register.ip=10.200.182.56&amp;side=consumer&amp;timestamp=1568614026921&amp;registry=nacos&amp;timestamp=1568614037122 这里的refprotocol ProtocolListenerWrapper#refer()-&gt;ProtocolFilterWrapper#refer()-&gt;RegistryProtocol#refer() RegistryProtocol#refer() 12345678910@Override@SuppressWarnings("unchecked")public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY); //通过url获取注册中心的实例 Registry registry = registryFactory.getRegistry(url); //选择配置的集群策略（cluster="failback"）或者默认策略 return doRefer(cluster, registry, type, url);&#125; 这里URL zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=dubbo-demo-api-consumer&amp;dubbo=2.0.2&amp;pid=6837&amp;refer=application%3Ddubbo-demo-api-consumer%26dubbo%3D2.0.2%26interface%3Dorg.apache.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D6837%26register.ip%3D10.200.183.188%26side%3Dconsumer%26timeout%3D3000000%26timestamp%3D1570760509261&amp;timestamp=1570760509508 最终获取到的注册中心URL地址 zookeeper://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService 2.2.2.获取注册中心&amp;注册中心通知123456789101112131415public Registry getRegistry(URL url) &#123; url = url.setPath(RegistryService.class.getName()) .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName()) .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY); //zookeeper://127.0.0.1:8848/com.alibaba.dubbo.registry.RegistryService LOCK.lock(); try &#123; //返回实例： new ZookeeperRegistry(url, zookeeperTransporter); registry = createRegistry(url); return registry; &#125; finally &#123; // Release the lock LOCK.unlock(); &#125;&#125; 12&gt; ZookeeperRegistry`-&gt;`FailbackRegistry`-&gt;`AbstractRegistry&gt; 2.2.3.引用远程服务12345678910111213141516171819202122232425262728private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123; RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url); directory.setRegistry(registry); directory.setProtocol(protocol); ... URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters); if (!Constants.ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123; URL registeredConsumerUrl = getRegisteredConsumerUrl(subscribeUrl, url); //服务消费者注册地址 registry.register(registeredConsumerUrl); directory.setRegisteredConsumerUrl(registeredConsumerUrl); &#125; //订阅服务提供者 directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + "," + Constants.CONFIGURATORS_CATEGORY + "," + Constants.ROUTERS_CATEGORY)); //服务的引用与变更全部由Directory异步完成 //集群策略会将Directory伪装成一个Invoker返回 //合并所有相同的invoker Invoker invoker = cluster.join(directory); ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory); return invoker;&#125; 服务消费地址 registeredConsumerUrl consumer://10.200.182.56/org.apache.dubbo.demo.DemoService?application=dubbo-demo-api-consumer&amp;category=consumers&amp;check=false&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=49619&amp;side=consumer&amp;timestamp=1568615207669 订阅url地址subscribeUrl consumer://10.200.182.56/org.apache.dubbo.demo.DemoService?application=dubbo-demo-api-consumer&amp;category=providers,configurators,routers&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=50488&amp;side=consumer&amp;timestamp=1568619762992 注册中心接收到消费者发送的订阅请求后，会根据提供者注册服务的列表，推送服务消息给消费者。消费者端接收到注册中心发来的提供者列表后，进行服务的引用。触发Directory监听器的可以是订阅请求，覆盖策略消息，路由策略消息。 2.2.4.订阅服务提供者12345public void subscribe(URL url) &#123; setConsumerUrl(url); //这里的registry是ZookeeperRegistry registry.subscribe(url, this);&#125; 看下registry.subscribe(url, this);，这里registry是ZookeeperRegistry，会先经过AbstractRegistry的处理，然后是FailbackRegistry的处理。 在AbstractRegistry中： 123456789101112//此时url为consumer://10.200.182.56/org.apache.dubbo.demo.DemoService?application=dubbo-demo-api-consumer&amp;category=providers,configurators,routers&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=50488&amp;side=consumer&amp;timestamp=1568619762992public void subscribe(URL url, NotifyListener listener) &#123; //先根据url获取已注册的监听器 Set&lt;NotifyListener&gt; listeners = subscribed.get(url); //没有监听器，就创建，并添加进去 if (listeners == null) &#123; subscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;()); listeners = subscribed.get(url); &#125; //有监听器，直接把当前RegistryDirectory添加进去 listeners.add(listener);&#125; 然后是FailbackRegistry中： 12345678public void subscribe(URL url, NotifyListener listener) &#123; super.subscribe(url, listener); removeFailedSubscribed(url, listener); try &#123; // 向服务器端发送订阅请求 doSubscribe(url, listener); &#125; catch (Exception e) &#123;...&#125;&#125; 继续看doSubscribe(url, listener);向服务端发送订阅请求，在ZookeeperRegistry中： 1234567891011121314151617181920212223242526272829303132333435363738protected void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;... &#125; else &#123; List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); for (String path : toCategoriesPath(url)) &#123; ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; //将zkClient的事件IZkChildListener转换到registry事件NotifyListener ChildListener zkListener = listeners.get(listener); if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)); &#125; &#125;); zkListener = listeners.get(listener); &#125; //创建三个节点 // /dubbo/dubbo.common.hello.service.HelloService/providers/ // /dubbo/dubbo.common.hello.service.HelloService/configurators/ // /dubbo/dubbo.common.hello.service.HelloService/routers/ //上面三个路径会被消费者端监听，当提供者，配置，路由发生变化之后， //注册中心会通知消费者刷新本地缓存。 zkClient.create(path, false); List&lt;String&gt; children = zkClient.addChildListener(path, zkListener); if (children != null) &#123; urls.addAll(toUrlsWithEmpty(url, path, children)); &#125; &#125; notify(url, listener, urls); &#125; &#125; catch (Throwable e) &#123; ... &#125;&#125; 2.2.5.服务订阅完之后的通知服务订阅完成之后，接着就是notify(url, listener, urls);： 会先经过FailbackRegistry将失败的通知请求记录到失败列表，定时重试。 1234567891011121314protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; try &#123; doNotify(url, listener, urls); &#125; catch (Exception t) &#123; // 将失败的通知请求记录到失败列表，定时重试 Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners = failedNotified.get(url); if (listeners == null) &#123; failedNotified.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;()); listeners = failedNotified.get(url); &#125; listeners.put(listener, urls); logger.error("Failed to notify for subscribe " + url + ", waiting for retry, cause: " + t.getMessage(), t); &#125;&#125; doNotify(url, listener, urls); 1234protected void doNotify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; //父类实现 super.notify(url, listener, urls);&#125; AbstractRegistry中的doNotify实现： 12345678910111213141516171819202122232425262728293031323334protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;String, List&lt;URL&gt;&gt;(); for (URL u : urls) &#123; if (UrlUtils.isMatch(url, u)) &#123; //不同类型的数据分开通知，providers，consumers，routers，overrides //允许只通知其中一种类型，但该类型的数据必须是全量的，不是增量的。 String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); List&lt;URL&gt; categoryList = result.get(category); if (categoryList == null) &#123; categoryList = new ArrayList&lt;URL&gt;(); result.put(category, categoryList); &#125; categoryList.add(u); &#125; &#125; if (result.size() == 0) &#123; return; &#125; Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url); if (categoryNotified == null) &#123; notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;()); categoryNotified = notified.get(url); &#125; //对这里得到的providers，configurators，routers分别进行通知 for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123; String category = entry.getKey(); List&lt;URL&gt; categoryList = entry.getValue(); categoryNotified.put(category, categoryList); //这里保存本地记录文件缓存信息 saveProperties(url); //这里的listener是RegistryDirectory listener.notify(categoryList); &#125;&#125; 到RegistryDirectory中查看notify方法： 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized void notify(List&lt;URL&gt; urls) &#123; List&lt;URL&gt; invokerUrls = new ArrayList&lt;URL&gt;(); List&lt;URL&gt; routerUrls = new ArrayList&lt;URL&gt;(); List&lt;URL&gt; configuratorUrls = new ArrayList&lt;URL&gt;(); for (URL url : urls) &#123; String protocol = url.getProtocol(); String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY); if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123; routerUrls.add(url); &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123; configuratorUrls.add(url); &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123; invokerUrls.add(url); &#125; else &#123; logger.warn("Unsupported category " + category + " in notified url: " + url + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost()); &#125; &#125; // configurators 更新缓存的服务提供方配置 if (configuratorUrls != null &amp;&amp; configuratorUrls.size() &gt;0 )&#123; this.configurators = toConfigurators(configuratorUrls); &#125; // routers//更新缓存的路由规则配置 if (routerUrls != null &amp;&amp; routerUrls.size() &gt;0 )&#123; List&lt;Router&gt; routers = toRouters(routerUrls); if(routers != null)&#123; // null - do nothing setRouters(routers); &#125; &#125; List&lt;Configurator&gt; localConfigurators = this.configurators; // local reference // 合并override参数 this.overrideDirectoryUrl = directoryUrl; if (localConfigurators != null &amp;&amp; localConfigurators.size() &gt; 0) &#123; for (Configurator configurator : localConfigurators) &#123; this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl); &#125; &#125; // providers //重建invoker实例 refreshInvoker(invokerUrls);&#125; 2.2.5.1.重建invoker实例1234567891011121314151617181920212223242526272829303132333435363738private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123; if (invokerUrls != null &amp;&amp; invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123; this.forbidden = true; // 禁止访问 this.methodInvokerMap = null; // 置空列表 destroyAllInvokers(); // 关闭所有invoker &#125; else &#123; this.forbidden = false; // 允许访问 Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls != null) &#123; invokerUrls.addAll(this.cachedInvokerUrls); &#125; else &#123; this.cachedInvokerUrls = new HashSet&lt;URL&gt;(); this.cachedInvokerUrls.addAll(invokerUrls);//缓存invokerUrls列表，便于交叉对比 &#125; if (invokerUrls.isEmpty()) &#123; return; &#125; //会重新走一遍服务的引用过程 //给每个提供者创建一个Invoker Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls); Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map // state change // If the calculation is wrong, it is not processed. if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123; ... return; &#125; this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap; this.urlInvokerMap = newUrlInvokerMap; try &#123; //关闭未使用的invoker destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker &#125; catch (Exception e) &#123; ... &#125; &#125;&#125; toInvokers(invokerUrls) 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123; Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = new HashMap&lt;String, Invoker&lt;T&gt;&gt;(); if(urls == null || urls.size() == 0)&#123; return newUrlInvokerMap; &#125; Set&lt;String&gt; keys = new HashSet&lt;String&gt;(); String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY); for (URL providerUrl : urls) &#123; //此时url是dubbo://10.200.182.56:20880/org.apache.dubbo.demo.DemoService?anyhost=true&amp;application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=48636&amp;side=provider&amp;timestamp=1568602364738 //从注册中心获取到的携带提供者信息的url //如果reference端配置了protocol，则只选择匹配的protocol if (queryProtocols != null &amp;&amp; queryProtocols.length() &gt;0) &#123; boolean accept = false; String[] acceptProtocols = queryProtocols.split(","); for (String acceptProtocol : acceptProtocols) &#123; if (providerUrl.getProtocol().equals(acceptProtocol)) &#123; accept = true; break; &#125; &#125; if (!accept) &#123; continue; &#125; &#125; if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123; continue; &#125; ... URL url = mergeUrl(providerUrl); String key = url.toFullString(); // URL参数是排序的 if (keys.contains(key)) &#123; // 重复URL continue; &#125; keys.add(key); // 缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = this.urlInvokerMap; // local reference Invoker&lt;T&gt; invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key); if (invoker == null) &#123; // 缓存中没有，重新refer try &#123; boolean enabled = true; if (url.hasParameter(Constants.DISABLED_KEY)) &#123; enabled = ! url.getParameter(Constants.DISABLED_KEY, false); &#125; else &#123; enabled = url.getParameter(Constants.ENABLED_KEY, true); &#125; if (enabled) &#123; //根据扩展点加载机制，这里使用的protocol是DubboProtocol invoker = new InvokerDelegete&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl); &#125; &#125; catch (Throwable t) &#123; logger.error("Failed to refer invoker for interface:"+serviceType+",url:("+url+")" + t.getMessage(), t); &#125; if (invoker != null) &#123; // 将新的引用放入缓存 newUrlInvokerMap.put(key, invoker); &#125; &#125;else &#123; newUrlInvokerMap.put(key, invoker); &#125; &#125; keys.clear(); return newUrlInvokerMap;&#125; 创建invoker invoker = new InvokerDelegete&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl); 先使用DubboProtocol的refer方法，这一步会依次调用ProtocolFIlterListenerWrapper，ProtocolFilterWrapper，DubboProtocol中的refer方法。经过两个Wrapper中，会添加对应的InvokerListener并构建Invoker Filter链，在DubboProtocol中会创建一个DubboInvoker对象，该Invoker对象持有服务Class，providerUrl，负责和服务提供端通信的ExchangeClient。 接着使用得到的Invoker创建一个InvokerDelegete 2.2.5.2.创建invoker在DubboProtocol中创建DubboInvoker的时候代码如下： 1234567public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; // create rpc invoker. //这里有一个getClients方法 DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers); invokers.add(invoker); return invoker;&#125; 查看getClients方法： 12345678910111213141516171819202122private ExchangeClient[] getClients(URL url)&#123; //是否共享连接 boolean service_share_connect = false; int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0); //如果connections不配置，则共享连接，否则每服务每连接 if (connections == 0)&#123; service_share_connect = true; connections = 1; &#125; ExchangeClient[] clients = new ExchangeClient[connections]; for (int i = 0; i &lt; clients.length; i++) &#123; if (service_share_connect)&#123; //这里没有配置connections，就使用getSharedClient //getSharedClient中先去缓存中查找，没有的话就会新建，也是调用initClient方法 clients[i] = getSharedClient(url); &#125; else &#123; clients[i] = initClient(url); &#125; &#125; return clients;&#125; 直接看initClient方法： 12345678910111213141516171819202122232425262728293031323334//创建新连接private ExchangeClient initClient(URL url) &#123; // client type setting. String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT)); String version = url.getParameter(Constants.DUBBO_VERSION_KEY); boolean compatible = (version != null &amp;&amp; version.startsWith("1.0.")); url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() &amp;&amp; compatible ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME); //默认开启heartbeat url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT)); // BIO存在严重性能问题，暂时不允许使用 if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException("Unsupported client type: " + str + "," + " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " ")); &#125; ExchangeClient client ; try &#123; //如果lazy属性没有配置为true（我们没有配置，默认为false）ExchangeClient会马上和服务端建立连接 //设置连接应该是lazy的 if (url.getParameter(Constants.LAZY_CONNECT_KEY, false))&#123; client = new LazyConnectExchangeClient(url ,requestHandler); &#125; else &#123; //立即和服务端建立连接 client = Exchangers.connect(url ,requestHandler); &#125; &#125; catch (RemotingException e) &#123; throw new RpcException("Fail to create remoting client for service(" + url + "): " + e.getMessage(), e); &#125; return client;&#125; 和服务端建立连接，Exchangers.connect(url ,requestHandler);，其实最后使用的是HeaderExchanger，Exchanger目前只有这一个实现： 1234567public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123; //先经过HeaderExchangeHandler包装 //然后是DecodeHandler //然后是Transporters.connect //返回一个HeaderExchangerClient，这里封装了client，channel，启动心跳的定时器等 return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))));&#125; Transporters.connect中也是根据SPI扩展获取Transport的具体实现，这里默认使用NettyTransporter.connect()，在NettyTransporter的connect方法中直接返回一个NettyClient(url, listener);，下面看下具体的NettyClient初始化细节，会先初始化AbstractPeer这里只是吧url和handler赋值；然后是AbstractEndpoint初始化： 1234567public AbstractEndpoint(URL url, ChannelHandler handler) &#123; super(url, handler); //获取编解码器，这里是DubboCountCodec this.codec = getChannelCodec(url); this.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); this.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);&#125; 接着是AbstractClient的初始化： 123456789101112131415public AbstractClient(URL url, ChannelHandler handler) throws RemotingException &#123; super(url, handler); send_reconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, false); shutdown_timeout = url.getParameter(Constants.SHUTDOWN_TIMEOUT_KEY, Constants.DEFAULT_SHUTDOWN_TIMEOUT); //默认重连间隔2s，1800表示1小时warning一次. reconnect_warning_period = url.getParameter("reconnect.waring.period", 1800); //1.具体实现在子类中 doOpen(); //2.连接 connect();&#125; 看下在NettyClient中doOpen()的实现： 1234567891011121314151617181920protected void doOpen() throws Throwable &#123; NettyHelper.setNettyLoggerFactory(); bootstrap = new ClientBootstrap(channelFactory); // config // @see org.jboss.netty.channel.socket.SocketChannelConfig bootstrap.setOption("keepAlive", true); bootstrap.setOption("tcpNoDelay", true); bootstrap.setOption("connectTimeoutMillis", getTimeout()); final NettyHandler nettyHandler = new NettyHandler(getUrl(), this); bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123; public ChannelPipeline getPipeline() &#123; NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this); ChannelPipeline pipeline = Channels.pipeline(); pipeline.addLast("decoder", adapter.getDecoder()); pipeline.addLast("encoder", adapter.getEncoder()); pipeline.addLast("handler", nettyHandler); return pipeline; &#125; &#125;);&#125; 这里是Netty3中的客户端连接的一些常规步骤，暂不做具体解析。open之后，就是真正连接服务端的操作了，connect()： 12345678910111213141516protected void connect() throws RemotingException &#123; connectLock.lock(); try &#123; if (isConnected()) &#123; return; &#125; //初始化重连的线程 initConnectStatusCheckCommand(); //连接，在子类中实现 doConnect(); reconnect_count.set(0); reconnect_error_log_flag.set(false); &#125; catch (RemotingException e) &#123;。。。&#125; finally &#123; connectLock.unlock(); &#125;&#125; NettyClient中的doConnect方法： 1234567891011121314151617181920212223242526272829303132333435363738protected void doConnect() throws Throwable &#123; long start = System.currentTimeMillis(); //消费者端开始连接，这一步的时候，服务提供者端就接到了连接请求，开始处理了 ChannelFuture future = bootstrap.connect(getConnectAddress()); try&#123; boolean ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS); if (ret &amp;&amp; future.isSuccess()) &#123; Channel newChannel = future.getChannel(); newChannel.setInterestOps(Channel.OP_READ_WRITE); try &#123; // 关闭旧的连接 Channel oldChannel = NettyClient.this.channel; // copy reference if (oldChannel != null) &#123; try &#123; oldChannel.close(); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(oldChannel); &#125; &#125; &#125; finally &#123; if (NettyClient.this.isClosed()) &#123; try &#123; newChannel.close(); &#125; finally &#123; NettyClient.this.channel = null; NettyChannel.removeChannelIfDisconnected(newChannel); &#125; &#125; else &#123; NettyClient.this.channel = newChannel; &#125; &#125; &#125; else if (future.getCause() != null) &#123; throw。。。 &#125; else &#123;throw 。。。 &#125; &#125;finally&#123; if (! isConnected()) &#123; future.cancel(); &#125; &#125;&#125; 这里连接的细节都交给了netty。 NettyClient初始化完成之后，返回给Transporters，再返回给HeaderExchanger，HeaderExchanger中将NettyClient包装成HeaderExchangeClient返回给DubboProtocol的initClient方法中，到此在getSharedClient中就获取到了一个ExchangeClient，然后包装一下返回client = new ReferenceCountExchangeClient(exchagneclient, ghostClientMap);。 到这里在DubboProtocol的refer方法中这句DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);创建DubboInvoker就已经解析完成，创建过程中连接了服务端，包含一个ExchangeClient等： 12345678public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; // create rpc invoker. DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers); //将invoker缓存 invokers.add(invoker); //返回invoker return invoker;&#125; 接着返回ProtocolFilterWrapper的refer方法，在这里会构建invoker链： 123456public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; return protocol.refer(type, url); &#125; return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);&#125; 接着再返回到ProtocolListenerWrapper的refer方法，这里会初始化监听器，包装： 123456789public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; return protocol.refer(type, url); &#125; return new ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url), Collections.unmodifiableList( ExtensionLoader.getExtensionLoader(InvokerListener.class) .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));&#125; 接着在返回到toInvokers方法，然后返回refreshInvoker方法的Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls) ;这就获得了Invoker，接着就是方法名映射Invoker列表：Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);这里将invokers列表转成与方法的映射关系。到这里refreshInvoker方法就完成了，在往上就返回到AbstractRegistry的notify方法，到这里也完成了。 2.2.6.创建服务代理到这里有关消费者端注册到注册中心和订阅注册中心就完事儿了，这部分是在RegistryProtocol.doRefer方法中，这个方法最后一句是return cluster.join(directory);，这里由Cluster组件创建一个Invoker并返回，这里的cluster默认是用FailoverCluster，最后返回的是经过MockClusterInvoker包装过的FailoverCluster。继续返回到ReferenceConfig中createProxy方法，这时候我们已经完成了消费者端引用服务的Invoker。然后最后返回的是根据我们得到的invoker创建的服务代理return (T) proxyFactory.getProxy(invoker);。这里proxyFactory是我们在最上面列出的动态生成的代码。 首先经过AbstractProxyFactory的处理： 1234567891011121314151617181920public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123; Class&lt;?&gt;[] interfaces = null; String config = invoker.getUrl().getParameter("interfaces"); if (config != null &amp;&amp; config.length() &gt; 0) &#123; String[] types = Constants.COMMA_SPLIT_PATTERN.split(config); if (types != null &amp;&amp; types.length &gt; 0) &#123; interfaces = new Class&lt;?&gt;[types.length + 2]; interfaces[0] = invoker.getInterface(); interfaces[1] = EchoService.class; for (int i = 0; i &lt; types.length; i ++) &#123; interfaces[i + 1] = ReflectUtils.forName(types[i]); &#125; &#125; &#125; if (interfaces == null) &#123; interfaces = new Class&lt;?&gt;[] &#123;invoker.getInterface(), EchoService.class&#125;; &#125; //这里默认使用的是JavassistProxyFactory的实现 return getProxy(invoker, interfaces);&#125; 然后经过StubProxyFactoryWrapper的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123; T proxy = proxyFactory.getProxy(invoker); if (GenericService.class != invoker.getInterface()) &#123; String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY)); if (ConfigUtils.isNotEmpty(stub)) &#123; Class&lt;?&gt; serviceType = invoker.getInterface(); if (ConfigUtils.isDefault(stub)) &#123; if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) &#123; stub = serviceType.getName() + "Stub"; &#125; else &#123; stub = serviceType.getName() + "Local"; &#125; &#125; try &#123; Class&lt;?&gt; stubClass = ReflectUtils.forName(stub); if (! serviceType.isAssignableFrom(stubClass)) &#123; &#125; try &#123; Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType); proxy = (T) constructor.newInstance(new Object[] &#123;proxy&#125;); //export stub service URL url = invoker.getUrl(); if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT))&#123; url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), ",")); url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString()); try&#123; export(proxy, (Class)invoker.getInterface(), url); &#125;catch (Exception e) &#123; &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; &#125; &#125; catch (Throwable t) &#123; &#125; &#125; &#125; return proxy;&#125; 返回代理。到此HelloService helloService = (HelloService) applicationContext.getBean(&quot;helloService&quot;);就解析完成了，得到了服务的代理，代理会被注册到Spring容器中，可以调用服务方法了。接下来的方法调用过程，是消费者发送请求，提供者处理，然后消费者接受处理结果的请求。 初始化的过程： 主要做了注册到注册中心 监听注册中心 连接到服务提供者端 创建代理。 这些都是为了下面消费者和提供者之间的通信做准备。]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 集群路由负载均衡]]></title>
    <url>%2F2019%2F10%2F08%2Fdubbo%2FDubbo%20%E9%9B%86%E7%BE%A4%E8%B7%AF%E7%94%B1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[1.集群的容错模式Failover Cluster这是dubbo中默认的集群容错模式 失败自动切换，当出现失败，重试其它服务器。 通常用于读操作，但重试会带来更长延迟。 可通过retries=”2”来设置重试次数(不含第一次)。 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。 通常用于非幂等性的写操作，比如新增记录。 Failsafe Cluster 失败安全，出现异常时，直接忽略。 通常用于写入审计日志等操作。 Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。 通常用于消息通知操作。 Forking Cluster 并行调用多个服务器，只要一个成功即返回。 通常用于实时性要求较高的读操作，但需要浪费更多服务资源。 可通过forks=”2”来设置最大并行数。 Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持) 通常用于通知所有提供者更新缓存或日志等本地资源信息。 2. 负载均衡dubbo默认的负载均衡策略是random，随机调用。 Random LoadBalance 随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 RoundRobin LoadBalance 轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 LeastActive LoadBalance 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 ConsistentHash LoadBalance 一致性Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 缺省只对第一个参数Hash。 缺省用160份虚拟节点。 3.源码解析3.1.调用方法入口com.alibaba.dubbo.registry.integration.RegistryProtocol#doRefer 12345678910private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123; RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url); directory.setRegistry(registry); directory.setProtocol(protocol); //默认FailoverCluster Invoker invoker = cluster.join(directory); ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory); return invoker;&#125; 返回的Invoker是一个MockClusterInvoker，MockClusterInvoker内部包含一个Directory和一个FailoverClusterInvoker。 1234567public class FailoverCluster implements Cluster &#123; public final static String NAME = "failover"; @Override public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123; return new FailoverClusterInvoker&lt;T&gt;(directory); &#125;&#125; Invoker都封装好了之后，就是创建代理，然后使用代理调用我们的要调用的方法。 3.2.调用方法时集群的处理在进行具体方法调用的时候，代理中会invoker.invoke()，这里Invoker就是我们上面封装好的MockClusterInvoker，所以首先进入MockClusterInvoker的invoke方法： 1234567891011121314151617181920212223242526272829303132public Result invoke(Invocation invocation) throws RpcException &#123; Result result = null; //我们没配置mock，所以这里为false //Mock通常用于服务降级 String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim(); //没有使用mock if (value.length() == 0 || value.equalsIgnoreCase("false"))&#123; //这里的invoker是FailoverClusterInvoker result = this.invoker.invoke(invocation); &#125; else if (value.startsWith("force")) &#123; //mock=force:return+null //表示消费方对方法的调用都直接返回null，不发起远程调用 //可用于屏蔽不重要服务不可用的时候，对调用方的影响 //force:direct mock result = doMockInvoke(invocation, null); &#125; else &#123; //mock=fail:return+null //表示消费方对该服务的方法调用失败后，再返回null，不抛异常 //可用于对不重要服务不稳定的时候，忽略对调用方的影响 //fail-mock try &#123; result = this.invoker.invoke(invocation); &#125;catch (RpcException e) &#123; if (e.isBiz()) &#123; throw e; &#125; else &#123; result = doMockInvoke(invocation, e); &#125; &#125; &#125; return result;&#125; 我们这里么有配置mock属性。首先进入的是AbstractClusterInvoker的incoke方法： 123456789101112131415public Result invoke(final Invocation invocation) throws RpcException &#123; //可以看到这里该处理负载均衡的问题了 LoadBalance loadbalance; //根据invocation中的信息从Directory中获取Invoker列表 //这一步中会进行路由的处理 List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation); if (invokers != null &amp;&amp; invokers.size() &gt; 0) &#123; //使用扩展机制，加载LoadBalance的实现类，默认使用的是random //我们这里得到的就是RandomLoadBalance loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl() .getMethodParameter(invocation.getMethodName(),Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE)); &#125; return doInvoke(invocation, invokers, loadbalance);&#125; 看下FailoverClusterInvoker#doInvoke方法： 1234567891011121314151617181920212223242526272829303132public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123; //Invoker列表 List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers; //确认下Invoker列表不为空 checkInvokers(copyinvokers, invocation); //重试次数,默认3次 int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1; // retry loop. RpcException le = null; // last exception. List&lt;Invoker&lt;T&gt;&gt; invoked = new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); // invoked invokers. Set&lt;String&gt; providers = new HashSet&lt;String&gt;(len); for (int i = 0; i &lt; len; i++) &#123; //重试时，进行重新选择，避免重试时invoker列表已发生变化. //注意：如果列表发生了变化，那么invoked判断会失效，因为invoker示例已经改变 if (i &gt; 0) &#123; checkWheatherDestoried(); copyinvokers = list(invocation); //重新检查一下 checkInvokers(copyinvokers, invocation); &#125; //使用loadBalance选择一个Invoker返回 Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked); invoked.add(invoker); RpcContext.getContext().setInvokers((List)invoked); //使用选择的结果Invoker进行调用，返回结果 Result result = invoker.invoke(invocation); return result; &#125;&#125; 先看下使用loadbalance选择invoker的select方法： 12345678910111213141516171819202122232425protected Invoker&lt;T&gt; select(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123; if (invokers == null || invokers.isEmpty()) return null; String methodName = invocation == null ? "" : invocation.getMethodName(); boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY); &#123; //ignore overloaded method if (stickyInvoker != null &amp;&amp; !invokers.contains(stickyInvoker)) &#123; stickyInvoker = null; &#125; //ignore concurrency problem if (sticky &amp;&amp; stickyInvoker != null &amp;&amp; (selected == null || !selected.contains(stickyInvoker))) &#123; if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123; return stickyInvoker; &#125; &#125; &#125; Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected); if (sticky) &#123; stickyInvoker = invoker; &#125; return invoker;&#125; doselect方法： 123456789101112131415161718192021222324252627282930313233private Invoker&lt;T&gt; doselect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123; if (invokers == null || invokers.size() == 0) return null; //只有一个invoker，直接返回，不需要处理 if (invokers.size() == 1) return invokers.get(0); // 如果只有两个invoker，退化成轮循 if (invokers.size() == 2 &amp;&amp; selected != null &amp;&amp; selected.size() &gt; 0) &#123; return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0); &#125; //使用loadBalance进行选择 Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation); //如果 selected中包含（优先判断） 或者 不可用&amp;&amp;availablecheck=true 则重试. if( (selected != null &amp;&amp; selected.contains(invoker)) ||(!invoker.isAvailable() &amp;&amp; getUrl()!=null &amp;&amp; availablecheck))&#123; try&#123; //重新选择 Invoker&lt;T&gt; rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck); if(rinvoker != null)&#123; invoker = rinvoker; &#125;else&#123; //看下第一次选的位置，如果不是最后，选+1位置. int index = invokers.indexOf(invoker); try&#123; //最后在避免碰撞 invoker = index &lt;invokers.size()-1?invokers.get(index+1) :invoker; &#125;catch (Exception e) &#123;。。。 &#125; &#125; &#125;catch (Throwable t)&#123;。。。&#125; &#125; return invoker;&#125; 接着看使用loadBalance进行选择，首先进入AbstractLoadBalance的select方法： 12345678public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; if (invokers == null || invokers.size() == 0) return null; if (invokers.size() == 1) return invokers.get(0); // 进行选择，具体的子类实现，我们这里是RandomLoadBalance return doSelect(invokers, url, invocation);&#125; 接着去RandomLoadBalance中查看： 1234567891011121314151617181920212223242526protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; int length = invokers.size(); // 总个数 int totalWeight = 0; // 总权重 boolean sameWeight = true; // 权重是否都一样 for (int i = 0; i &lt; length; i++) &#123; int weight = getWeight(invokers.get(i), invocation); totalWeight += weight; // 累计总权重 if (sameWeight &amp;&amp; i &gt; 0 &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) &#123; sameWeight = false; // 计算所有权重是否一样 &#125; &#125; if (totalWeight &gt; 0 &amp;&amp; ! sameWeight) &#123; // 如果权重不相同且权重大于0则按总权重数随机 int offset = random.nextInt(totalWeight); // 并确定随机值落在哪个片断上 for (int i = 0; i &lt; length; i++) &#123; offset -= getWeight(invokers.get(i), invocation); if (offset &lt; 0) &#123; return invokers.get(i); &#125; &#125; &#125; // 如果权重相同或权重为0则均等随机 return invokers.get(random.nextInt(length));&#125; 上面根据权重之类的来进行选择一个Invoker返回。接下来reselect的方法不在说明，是先从非selected的列表中选择，没有在从selected列表中选择。 选择好了Invoker之后，就回去FailoverClusterInvoker的doInvoke方法，接着就是根据选中的Invoker调用invoke方法进行返回结果，接着就是到具体的Invoker进行调用的过程了。这部分的解析在消费者和提供者请求响应过程已经解析过了，不再重复。 3.3.路由策略回到AbstractClusterInvoker的invoke方法中，这里有一步是List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);获取Invoker列表，这里同时也进行了路由的操作，看下list方法： 1234protected List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123; List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation); return invokers;&#125; 接着看AbstractDirectory的list方法： 1234567891011121314151617181920public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123; if (destroyed)&#123; throw new RpcException("Directory already destroyed .url: "+ getUrl()); &#125; //RegistryDirectory中的doList实现 List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation); List&lt;Router&gt; localRouters = this.routers; // local reference if (localRouters != null &amp;&amp; localRouters.size() &gt; 0) &#123; for (Router router: localRouters)&#123; try &#123; if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, true)) &#123; //路由选择 //MockInvokersSelector中 invokers = router.route(invokers, getConsumerUrl(), invocation); &#125; &#125; catch (Throwable t) &#123;。。。&#125; &#125; &#125; return invokers;&#125; 路由来过滤之后，进行负载均衡的处理。 4.Dubbo一致性hash实现4.1.一致性哈希负载均衡配置1234567891011&lt;!-- 配置接口 --&gt;&lt;dubbo:service interface="..." loadbalance="consistenthash" /&gt;&lt;dubbo:reference interface="..." loadbalance="consistenthash" /&gt;&lt;!-- 配置方法 --&gt;&lt;dubbo:service interface="..."&gt; &lt;dubbo:method name="..." loadbalance="consistenthash"/&gt;&lt;/dubbo:service&gt;&lt;dubbo:reference interface="..."&gt; &lt;dubbo:method name="..." loadbalance="consistenthash"/&gt;&lt;/dubbo:reference&gt; 4.2.主要配置参数一致性Hash负载均衡涉及到两个主要的配置参数为 hash.arguments 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode hash.nodes 为结点的副本数 4.3.ConsistentHashSelector详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private static final class ConsistentHashSelector&lt;T&gt; &#123; //虚拟节点 private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; //副本数，默认160 private final int replicaNumber; //hashcode private final int identityHashCode; private final int[] argumentIndex; ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123; //创建TreeMap来保持结点 this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;(); this.identityHashCode = identityHashCode; URL url = invokers.get(0).getUrl(); // 获取所配置的结点数，如没有设置则使用默认值160 this.replicaNumber = url.getMethodParameter(methodName, "hash.nodes", 160); //获取需要进行hash的参数数组索引，默认对第一个参数进行hash String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, "hash.arguments", "0")); argumentIndex = new int[index.length]; for (int i = 0; i &lt; index.length; i++) &#123; argumentIndex[i] = Integer.parseInt(index[i]); &#125; // 创建虚拟结点 // 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中 for (Invoker&lt;T&gt; invoker : invokers) &#123; String address = invoker.getUrl().getAddress(); for (int i = 0; i &lt; replicaNumber / 4; i++) &#123; // 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。 byte[] digest = md5(address + i); // 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0 // 并作为虚拟结点的key。 for (int h = 0; h &lt; 4; h++) &#123; long m = hash(digest, h); virtualInvokers.put(m, invoker); &#125; &#125; &#125; &#125; // 选择结点 public Invoker&lt;T&gt; select(Invocation invocation) &#123; // 根据调用参数来生成Key String key = toKey(invocation.getArguments()); // 根据这个参数生成消息摘要 byte[] digest = md5(key); //调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode //调用sekectForKey方法选择结点。 Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, 0)); return invoker; &#125; private String toKey(Object[] args) &#123; StringBuilder buf = new StringBuilder(); //由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key for (int i : argumentIndex) &#123; if (i &gt;= 0 &amp;&amp; i &lt; args.length) &#123; buf.append(args[i]); &#125; &#125; return buf.toString(); &#125; private Invoker&lt;T&gt; selectForKey(long hash) &#123; Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.tailMap(hash, true).firstEntry(); if (entry == null) &#123; entry = virtualInvokers.firstEntry(); &#125; return entry.getValue(); &#125;&#125; 在进行选择时候若HashCode，有三种情况： 直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。 若不相等，则通过virtualInvokers.tailMap(hash).firstKey()找到大于该hash值的集合，并通过firstKey()方法找到第一个值返回 若返回值为null，则说明该hash值已经在最大值区间了，则直接返回第一个虚拟节点virtualInvokers.firstEntry() 4.4.测试一致性hash代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class ConsistentHashHasVirtualNode &#123; // 待添加入Hash环的服务器列表 private static String[] servers = &#123; "192.168.1.0:111", "192.168.1.1:111", "192.168.1.2:111", "192.168.1.3:111","192.168.1.4:111" &#125;; // 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好 private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;(); // 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称 private static SortedMap&lt;Integer, String&gt; virtualNodes = new TreeMap&lt;Integer, String&gt;(); // 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点 private static final int VIRTUAL_NODES = 5; static &#123; // 先把原始的服务器添加到真实结点列表中 for (int i = 0; i &lt; servers.length; i++) realNodes.add(servers[i]); // 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高 for (String str : realNodes) &#123; for (int i = 0; i &lt; VIRTUAL_NODES; i++) &#123; String virtualNodeName = str + "&amp;&amp;VN" + String.valueOf(i); int hash = getHash(virtualNodeName); System.out.println("虚拟节点[" + virtualNodeName + "]被添加, hash值为" + hash); virtualNodes.put(hash, virtualNodeName); &#125; &#125; System.out.println(); &#125; // 使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别 private static int getHash(String str) &#123; final int p = 16777619; int hash = (int) 2166136261L; for (int i = 0; i &lt; str.length(); i++) hash = (hash ^ str.charAt(i)) * p; hash += hash &lt;&lt; 13; hash ^= hash &gt;&gt; 7; hash += hash &lt;&lt; 3; hash ^= hash &gt;&gt; 17; hash += hash &lt;&lt; 5; // 如果算出来的值为负数则取其绝对值 if (hash &lt; 0) hash = Math.abs(hash); return hash; &#125; // 得到应当路由到的结点 private static String getServer(String key) &#123; // 得到该key的hash值 int hash = getHash(key); // 得到大于该Hash值的所有Map SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash); String virtualNode; if (subMap.isEmpty()) &#123; // 如果没有比该key的hash值大的，则从第一个node开始 Integer i = virtualNodes.firstKey(); // 返回对应的服务器 virtualNode = virtualNodes.get(i); &#125; else &#123; // 第一个Key就是顺时针过去离node最近的那个结点 Integer i = subMap.firstKey(); // 返回对应的服务器 virtualNode = subMap.get(i); &#125; // virtualNode虚拟节点名称要截取一下 if (virtualNode != null &amp;&amp; virtualNode != "") &#123; return virtualNode.substring(0, virtualNode.indexOf("&amp;&amp;")); &#125; return null; &#125; public static void main(String[] args) &#123; String[] keys = &#123; "太阳", "月亮", "星星", "白云", "蓝天" &#125;; for (int i = 0; i &lt; keys.length; i++) System.out.println("[" + keys[i] + "]的hash值为" + getHash(keys[i]) + ", 被路由到结点[" + getServer(keys[i]) + "]"); &#125;&#125;]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo编码与解码流程]]></title>
    <url>%2F2019%2F10%2F03%2Fdubbo%2FDubbo%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.Dubbo编码与解码流程 2.Dubbo创建请求流程 3.Dubbo线程池处理流程 4.Dubbo创建服务调用流程]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo ExtensionLoader详解]]></title>
    <url>%2F2019%2F10%2F02%2Fdubbo%2FExtensionLoader%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.调用流程图 2.ExtensionLoader组成部分 3.源码分析测试程序 123456789public static void main(String[] args) &#123; ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class); Protocol protocol = loader.getExtension("registry"); System.out.println(protocol.getClass()); Protocol autowireProtocol = loader.getAdaptiveExtension(); System.out.println(autowireProtocol.getClass());&#125; 3.1.根据type获取ExtensionLoader 判断是否为null 判断是否是接口 判断接口是否有@SPI注解 创建新的ExtensionLoader 12345678910111213141516171819202122public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123; //判断是否为null if (type == null)&#123; ... &#125; //判断是否是接口 if (!type.isInterface()) &#123; ... &#125; //判断接口是否有@SPI注解 if (!withExtensionAnnotation(type)) &#123; ... &#125; //从缓存获取 ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); if (loader == null) &#123; //创建新的ExtensionLoader EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type)); loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); &#125; return loader;&#125; 3.2.创建ExtensionLoader实例123456private ExtensionLoader(Class&lt;?&gt; type) &#123; this.type = type; //如果type 不等于 ExtensionFactory，则获取自适应Factory,主要用于实例化对象时，set方法的注入,来获取注入协议的自适应AdaptiveExtension实例 //例如：RegistryProtocol中的set方法 : setProtocol、setCluster、setRegistryFactory等 objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());&#125; 3.3.根据name获取真实对象实例123456789101112131415161718192021222324public T getExtension(String name) &#123; ... //如果name=true，则返回默认值 if ("true".equals(name)) &#123; return getDefaultExtension(); &#125; Holder&lt;Object&gt; holder = cachedInstances.get(name); if (holder == null) &#123; cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;()); holder = cachedInstances.get(name); &#125; Object instance = holder.get(); //缓存为null if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; instance = createExtension(name); holder.set(instance); &#125; &#125; &#125; return (T) instance;&#125; 1.getExtensionClasses方法执行过程 1234567891011121314private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123; Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get(); if (classes == null) &#123; synchronized (cachedClasses) &#123; classes = cachedClasses.get(); //缓存为null if (classes == null) &#123; classes = loadExtensionClasses(); cachedClasses.set(classes); &#125; &#125; &#125; return classes;&#125; 2.loadClass方法执行过程 如果该实现类中有@Adaptive注解，只能有一个 如果是包装类，主要用于类似于AOP，可以有多个 普通实现类处理，主要处理@Activate自动激活类和普通实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123; //如果该实现类中有@Adaptive注解，只能有一个 if (clazz.isAnnotationPresent(Adaptive.class)) &#123; if (cachedAdaptiveClass == null) &#123; cachedAdaptiveClass = clazz; &#125; else if (!cachedAdaptiveClass.equals(clazz)) &#123; throw new IllegalStateException("More than 1 adaptive class found: " + cachedAdaptiveClass.getClass().getName() + ", " + clazz.getClass().getName()); &#125; &#125; //如果是包装类，主要用于类似于AOP，可以有多个 else if (isWrapperClass(clazz)) &#123; Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses; if (wrappers == null) &#123; cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;(); wrappers = cachedWrapperClasses; &#125; wrappers.add(clazz); &#125; //普通实现类处理，主要处理@Activate自动激活类和普通实现类 else &#123; clazz.getConstructor(); if (name == null || name.length() == 0) &#123; name = findAnnotationName(clazz); &#125; String[] names = NAME_SEPARATOR.split(name); if (names != null &amp;&amp; names.length &gt; 0) &#123; Activate activate = clazz.getAnnotation(Activate.class); if (activate != null) &#123; cachedActivates.put(names[0], activate); &#125; for (String n : names) &#123; if (!cachedNames.containsKey(clazz)) &#123; cachedNames.put(clazz, n); &#125; Class&lt;?&gt; c = extensionClasses.get(n); if (c == null) &#123; //加入缓存 extensionClasses.put(n, clazz); &#125; &#125; &#125; &#125;&#125;//判断是否是包装类，构造方法private boolean isWrapperClass(Class&lt;?&gt; clazz) &#123; try &#123; clazz.getConstructor(type); return true; &#125; catch (NoSuchMethodException e) &#123; return false; &#125;&#125; 3.createExtension(String name)创建实例过程 12345678910111213141516171819202122232425262728private T createExtension(String name) &#123; //根据缓存中查询该name对应的Class对象 Class&lt;?&gt; clazz = getExtensionClasses().get(name); if (clazz == null) &#123; throw findException(name); &#125; try &#123; T instance = (T) EXTENSION_INSTANCES.get(clazz); if (instance == null) &#123; //实例化对象instance EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); &#125; //instance对象注入属性，类似于IOC injectExtension(instance); Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; //加入包装类 if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; //通过构造方法实例化对象 instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); &#125; &#125; return instance; &#125; catch (Throwable t) &#123; ... &#125;&#125; 4.injectExtension注入对象属性过程 12345678910111213141516171819202122232425262728293031private T injectExtension(T instance) &#123; try &#123; if (objectFactory != null) &#123; for (Method method : instance.getClass().getMethods()) &#123; //set方法判断逻辑 if (method.getName().startsWith("set") &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; if (method.getAnnotation(DisableInject.class) != null) &#123; continue; &#125; Class&lt;?&gt; pt = method.getParameterTypes()[0]; try &#123; String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : ""; //获取注入对象 [objectFactory = SpiExtensionFactory] Object object = objectFactory.getExtension(pt, property); if (object != null) &#123; //执行注入动作 method.invoke(instance, object); &#125; &#125; catch (Exception e) &#123; ... &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; ... &#125; return instance;&#125; 3.4.获取SPI接口类型的自适应实例对象123456789101112131415161718192021222324public T getAdaptiveExtension() &#123; Object instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; if (createAdaptiveInstanceError == null) &#123; synchronized (cachedAdaptiveInstance) &#123; instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; try &#123; //创建 instance = createAdaptiveExtension(); cachedAdaptiveInstance.set(instance); &#125; catch (Throwable t) &#123; createAdaptiveInstanceError = t; throw new IllegalStateException("fail to create adaptive instance: " + t.toString(), t); &#125; &#125; &#125; &#125; else &#123; ... &#125; &#125; return (T) instance;&#125; 1.createAdaptiveExtension创建自适应对象 12345678910111213141516171819202122232425private T createAdaptiveExtension() &#123; try &#123; //实例化对象 return injectExtension((T) getAdaptiveExtensionClass().newInstance()); &#125; catch (Exception e) &#123; ... &#125;&#125;private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; getExtensionClasses(); //缓存中是否存在AdaptiveClass if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; return cachedAdaptiveClass = createAdaptiveExtensionClass();&#125;private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; //得到创建code String code = createAdaptiveExtensionClassCode(); ClassLoader classLoader = findClassLoader(); com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); return compiler.compile(code, classLoader);&#125;]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo 简要流程]]></title>
    <url>%2F2019%2F09%2F24%2Fdubbo%2FDubbo%20%E7%AE%80%E8%A6%81%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.Dubbo调用流程 2.底层netty通信 3.核心组件Service业务层：包括业务代码的接口与实现，即开发者实现的业务代码 Config配置层：主要围绕ServiceConfig（暴露的服务配置）和ReferenceCofig（引用的服务配置）两个实现类展开，初始化配置信息。Config中管理了整个Dubbo的配置 Proxy服务代理层：在Dubbo中，无论是服务提供者，还是服务消费者，框架都会生成一个代理类。 Registry注册层：负责Dubbo框架的服务注册与发现。当有新的服务加入或旧服务下线时，注册中心都会感知并通知给所有订阅方。 Cluster集群容错层：该层主要包含了以下的功能 远程调用失败时的容错机制（失败重试，快速失败） 调用服务时的负载均衡 特殊调用路径的路由策略 Monitor监控层：这一层主要负责监控统计调用次数和调用时间等。 Protocol远程调用层：封装RPC调用具体过程，Protocol是Invoker暴露和引用的主功能入口，它负责Invoker的整个生命周期，Invoker是Dubbo的核心模型。 Exchange信息交换层：建立Request-Response模型，封装请求响应模式，如把同步请求转化为异步请求。 Transport网络传输层：把网络传输抽象为统一的接口。 Serialize序列化层：负责管理整个框架网络传输时的序列化/反序列化工作]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo QOS命令]]></title>
    <url>%2F2019%2F09%2F09%2Fdubbo%2FDubbo%20QOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dubbo 2.5.8 新版本增加了 QOS 模块，提供了新的 telnet 命令支持。 端口新版本的 telnet 端口 与 dubbo 协议的端口是不同的端口，默认为 22222，可通过配置文件dubbo.properties 修改: 1dubbo.application.qos.port=33333 或者通过设置 JVM 参数: 1-Ddubbo.application.qos.port=33333 安全默认情况下，dubbo 接收任何主机发起的命令，可通过配置文件dubbo.properties 修改: 1dubbo.application.qos.accept.foreign.ip=false 或者通过设置 JVM 参数: 1-Ddubbo.application.qos.accept.foreign.ip=false 拒绝远端主机发出的命令，只允许服务本机执行 telnet 与 http 协议telnet 模块现在同时支持 http 协议和 telnet 协议，方便各种情况的使用 示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940➜ ~ telnet localhost 22222Trying ::1...telnet: connect to address ::1: Connection refusedTrying 127.0.0.1...Connected to localhost.Escape character is '^]'. ████████▄ ███ █▄ ▀█████████▄ ▀█████████▄ ▄██████▄ ███ ▀███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ▄███▄▄▄██▀ ▄███▄▄▄██▀ ███ ███ ███ ███ ███ ███ ▀▀███▀▀▀██▄ ▀▀███▀▀▀██▄ ███ ███ ███ ███ ███ ███ ███ ██▄ ███ ██▄ ███ ███ ███ ▄███ ███ ███ ███ ███ ███ ███ ███ ███ ████████▀ ████████▀ ▄█████████▀ ▄█████████▀ ▀██████▀dubbo&gt;lsAs Provider side:+----------------------------------+---+| Provider Service Name |PUB|+----------------------------------+---+|org.apache.dubbo.demo.DemoService| N |+----------------------------------+---+As Consumer side:+---------------------+---+|Consumer Service Name|NUM|+---------------------+---+dubbo&gt;➜ ~ curl "localhost:22222/ls?arg1=xxx&amp;arg2=xxxx"As Provider side:+----------------------------------+---+| Provider Service Name |PUB|+----------------------------------+---+|org.apache.dubbo.demo.DemoService| N |+----------------------------------+---+As Consumer side:+---------------------+---+|Consumer Service Name|NUM|+---------------------+---+ 支持的命令ls 列出消费者和提供者1234567891011dubbo&gt;lsAs Provider side:+----------------------------------+---+| Provider Service Name |PUB|+----------------------------------+---+|org.apache.dubbo.demo.DemoService| Y |+----------------------------------+---+As Consumer side:+---------------------+---+|Consumer Service Name|NUM|+---------------------+---+ 列出 dubbo 的所提供的服务和消费的服务，以及消费的服务地址数 Online 上线服务命令当使用延迟发布功能的时候(通过设置 org.apache.dubbo.config.AbstractServiceConfig#register 为 false)，后续需要上线的时候，可通过 Online 命令 1234567//上线所有服务dubbo&gt;onlineOK//根据正则，上线部分服务dubbo&gt;online com.*OK 常见使用场景： 当线上的 QPS 比较高的时候，当刚重启机器的时候，由于没有进行JIT 预热或相关资源没有预热，可能会导致大量超时，这个时候，可通过分批发布服务，逐渐加大流量 当由于某台机器由于某种原因，需要下线服务，然后又需要重新上线服务 Offline 下线服务命令由于故障等原因，需要临时下线服务保持现场，可以使用 Offline 下线命令。 1234567//下线所有服务dubbo&gt;offlineOK//根据正则，下线部分服务dubbo&gt;offline com.*OK help 命令12345678910111213//列出所有命令dubbo&gt;help//列出单个命令的具体使用情况dubbo&gt;help online+--------------+----------------------------------------------------------------------------------+| COMMAND NAME | online |+--------------+----------------------------------------------------------------------------------+| EXAMPLE | online dubbo || | online xx.xx.xxx.service |+--------------+----------------------------------------------------------------------------------+dubbo&gt; 相关参数说明QoS提供了一些启动参数，来对启动进行配置，他们主要包括： 参数 说明 默认值 qosEnable 是否启动QoS true qosPort 启动QoS绑定的端口 22222 qosAcceptForeignIp 是否允许远程访问 false 注意，从2.6.4/2.7.0开始，qosAcceptForeignIp默认配置改为false，如果qosAcceptForeignIp设置为true，有可能带来安全风险，请仔细评估后再打开。 QoS参数可以通过如下方式进行配置 系统属性 dubbo.properties XML方式 Spring-boot自动装配方式 其中，上述方式的优先顺序为系统属性 &gt; dubbo.properties &gt; XML/Spring-boot自动装配方式。 使用系统属性方式进行配置123-Ddubbo.application.qos.enable=true-Ddubbo.application.qos.port=33333-Ddubbo.application.qos.accept.foreign.ip=false 使用dubbo.properties文件进行配置在项目的src/main/resources目录下添加dubbo.properties文件，内容如下: 123dubbo.application.qos.enable=truedubbo.application.qos.port=33333dubbo.application.qos.accept.foreign.ip=false 使用XML方法进行配置如果要通过XML配置响应的QoS相关的参数，可以进行如下配置： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="demo-provider"&gt; &lt;dubbo:parameter key="qos.enable" value="true"/&gt; &lt;dubbo:parameter key="qos.accept.foreign.ip" value="false"/&gt; &lt;dubbo:parameter key="qos.port" value="33333"/&gt; &lt;/dubbo:application&gt; &lt;dubbo:registry address="multicast://224.5.6.7:1234"/&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;dubbo:service interface="org.apache.dubbo.demo.provider.DemoService" ref="demoService"/&gt; &lt;bean id="demoService" class="org.apache.dubbo.demo.provider.DemoServiceImpl"/&gt;&lt;/beans&gt; 使用spring-boot自动装配方式配置如果是spring-boot的应用，可以在application.properties或者application.yml上配置: 123dubbo.application.qosEnable=truedubbo.application.qosPort=33333dubbo.application.qosAcceptForeignIp=false]]></content>
      <categories>
        <category>dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot外部化配置]]></title>
    <url>%2F2019%2F08%2F31%2Fspring%2FSpringBoot%E7%B3%BB%E5%88%97%2FSpring%20Boot%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.扩展外部化配置阶段 基于接口扩展 基于ApplicationContextInitializer接口扩展 基于EnvironmentPostProcessor接口扩展 基于SpringApplicationRunListener接口扩展 基于事件扩展 基于ApplicationEnvironmentPreparedEvent事件 基于ApplicationContextInitializedEvent事件 基于ApplicationPreparedEvent事件]]></content>
      <categories>
        <category>Spring Boot 系列</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConfigurationClassPostProcessor类解析]]></title>
    <url>%2F2019%2F08%2F25%2Fspring%2FSpringFramework%E7%B3%BB%E5%88%97%2FConfigurationClassPostProcessor%E7%B1%BB%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.整体解析流程图 2.执行阶段 AbstractApplicationContext#refresh AbstractApplicationContext#invokeBeanFactoryPostProcessors PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); //获取已经注册的bean名称 String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); //如果BeanDefinition中的configurationClass 属性为full 或者lite ,则意味着已经处理过了,直接跳过 if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123; &#125; //关键点1 else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125;... //@Order值进行排序 configCandidates.sort((bd1, bd2) -&gt; &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); &#125;);... if (this.environment == null) &#123; this.environment = new StandardEnvironment(); &#125; //解析每一个 @Configuration 类 ,关键点2 ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);... do &#123; //进行解析 parser.parse(candidates); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; this.reader.loadBeanDefinitions(configClasses);... &#125; while (!candidates.isEmpty()); 关键点1：ConfigurationClassUtils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static &#123; candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName());&#125;public static boolean checkConfigurationClassCandidate( BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) &#123;... if (isFullConfigurationCandidate(metadata)) &#123; beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); &#125; else if (isLiteConfigurationCandidate(metadata)) &#123; beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE); &#125; else &#123; return false; &#125; //排序 Integer order = getOrder(metadata); if (order != null) &#123; beanDef.setAttribute(ORDER_ATTRIBUTE, order); &#125; return true;&#125;//full 类判断public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) &#123; return metadata.isAnnotated(Configuration.class.getName());&#125;//lite 类判断public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) &#123; // Any of the typical annotations found? for (String indicator : candidateIndicators) &#123; if (metadata.isAnnotated(indicator)) &#123; return true; &#125; &#125; // Finally, let's look for @Bean methods... try &#123; return metadata.hasAnnotatedMethods(Bean.class.getName()); &#125;&#125;//full 或者 lite 类判断public static boolean isConfigurationCandidate(AnnotationMetadata metadata) &#123; return (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata));&#125; 3.ConfigurationClassParser注解解析 解析顺序 @Component.class @PropertySources.class @ComponentScans.class @Import.class @ImportResource.class @Bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; //1.解析@Component if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123; processMemberClasses(configClass, sourceClass); &#125; //2.解析@PropertySources for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; &#125; //3.解析@ComponentScan Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) &#123; bdCand = holder.getBeanDefinition(); &#125; if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123; parse(bdCand.getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; //4.解析@Import processImports(configClass, sourceClass, getImports(sourceClass), true); //5.@ImportResource AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) &#123; String[] resources = importResource.getStringArray("locations"); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; //6.解析@Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; //如果有父类的话,则返回父类进行进一步的解析 if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (!superclass.startsWith("java") &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; return null;&#125; 1.解析@Component 12345678910111213141516171819202122232425262728//内部类判断private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses(); if (!memberClasses.isEmpty()) &#123; List&lt;SourceClass&gt; candidates = new ArrayList&lt;&gt;(memberClasses.size()); for (SourceClass memberClass : memberClasses) &#123; //如果该内部类是一个配置类,并且该内部类的类名和configClass的类名不相同 if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &amp;&amp; !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) &#123; candidates.add(memberClass); &#125; &#125; OrderComparator.sort(candidates); for (SourceClass candidate : candidates) &#123; //如果importStack 包含该configClass的化,则意味发生了循环依赖,则会抛出BeanDefinitionParsingException 异常 if (this.importStack.contains(configClass)) &#123; this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); &#125; else &#123; ... //🚩标注需要importedBy的类 processConfigurationClass(candidate.asConfigClass(configClass)); ... &#125; &#125; &#125; &#125;&#125; 2.解析@PropertySources 12345678910111213141516171819private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123;... String[] locations = propertySource.getStringArray("value"); //是否忽略 boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; //对location进行SPEL表达式的解析 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); //使用资源加载器resourceLoader将resolvedLocation抽象为Resource Resource resource = this.resourceLoader.getResource(resolvedLocation); //调用addPropertySource属性进行处理。将指定的资源处理之后，添加到当前springboot运行的环境中 addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125;&#125; 3.解析@ComponentScan 12345678910111213141516171819202122232425262728protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; //扫描basePackage路径下的java文件 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; // 检查当前bean是否已经注册 if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); // 如果当前bean是用于生成代理的bean那么需要进一步处理 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions;&#125; 4.解析@Import注解 12345678910111213141516/** *获取所有的@Import类 */private void collectImports(SourceClass sourceClass, Set&lt;SourceClass&gt; imports, Set&lt;SourceClass&gt; visited) throws IOException &#123; if (visited.add(sourceClass)) &#123; for (SourceClass annotation : sourceClass.getAnnotations()) &#123; String annName = annotation.getMetadata().getClassName(); if (!annName.equals(Import.class.getName())) &#123; collectImports(annotation, imports, visited); &#125; &#125; imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value")); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334for (SourceClass candidate : importCandidates) &#123; //如果是ImportSelector的子类 if (candidate.isAssignable(ImportSelector.class)) &#123; Class&lt;?&gt; candidateClass = candidate.loadClass(); //则实例化后,调用ParserStrategyUtils#invokeAwareMethods ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class); ParserStrategyUtils.invokeAwareMethods( selector, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) &#123; this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); &#125; else &#123; String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); //迭代处理import类 processImports(configClass, currentSourceClass, importSourceClasses, false); &#125; &#125; //如果是ImportBeanDefinitionRegistrar的子类 else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123; Class&lt;?&gt; candidateClass = candidate.loadClass(); //则实例化后,调用ParserStrategyUtils#invokeAwareMethods ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class); ParserStrategyUtils.invokeAwareMethods( registrar, this.environment, this.resourceLoader, this.registry); ///🚩加入importBeanDefinitionRegistrars缓存 configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); &#125; else &#123; //🚩标注需要importedBy的类 processConfigurationClass(candidate.asConfigClass(configClass)); &#125;&#125; 5.解析@ImportResource 1234567891011AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);if (importResource != null) &#123; String[] resources = importResource.getStringArray("locations"); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); //🚩加入importedResources缓存 configClass.addImportedResource(resolvedResource, readerClass); &#125;&#125; 6.解析@Bean方法 123456//检索该 Class 中所有的 @Bean 方法Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);for (MethodMetadata methodMetadata : beanMethods) &#123; //🚩加入beanMethods缓存 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));&#125; 12345678910111213private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; for (SourceClass ifc : sourceClass.getInterfaces()) &#123; Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(ifc); for (MethodMetadata methodMetadata : beanMethods) &#123; //特殊处理：如果不是抽象方法 if (!methodMetadata.isAbstract()) &#123; //🚩加入beanMethods缓存 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; &#125; processInterfaces(configClass, ifc); &#125;&#125; 4.处理每个ConfigurationClass中的缓存数据123456789101112131415161718192021222324private void loadBeanDefinitionsForConfigurationClass( ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123;//Conditional Class条件类判断 if (trackedConditionEvaluator.shouldSkip(configClass)) &#123; String beanName = configClass.getBeanName(); if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) &#123; this.registry.removeBeanDefinition(beanName); &#125; this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); return; &#125; //@Component @Import 处理 【importedBy缓存】 if (configClass.isImported()) &#123; registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; //@Bean 处理 【beanMethods缓存】 for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; loadBeanDefinitionsForBeanMethod(beanMethod); &#125; //@ImportResource 处理 【importedResources缓存】 loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); // 【importBeanDefinitionRegistrars缓存】 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());&#125; 5.@Configuration增强生成代理对象5.1.执行流程图 5.2.执行阶段 AbstractApplicationContext#refresh AbstractApplicationContext#invokeBeanFactoryPostProcessors PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors ConfigurationClassPostProcessor#postProcessBeanFactory 1234567891011121314151617181920212223242526272829public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); //判断是否@Configuration.class 【full属性】 if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; ... //生成增强类 ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try &#123; // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); if (configClass != null) &#123; Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; //设置为增强类 beanDef.setBeanClass(enhancedClass); &#125; &#125; &#125; &#125;&#125; 增强ConfigurationClassEnhancer#newEnhancer 123456789101112131415161718private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) &#123; Enhancer enhancer = new Enhancer(); //设置父类Configuration enhancer.setSuperclass(configSuperClass); //用于设置beanFactory enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;); enhancer.setUseFactory(false); //用于命名BySpringCGLIB enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); //定义beanFactory属性名，[$$beanFactory] enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)); // 设置代理回调： // BeanMethodInterceptor，**核心@Bean方法调用**。 // BeanFactoryAwareMethodInterceptor，提供setBeanFactory(BeanFactory)调用 enhancer.setCallbackFilter(CALLBACK_FILTER); enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()); return enhancer;&#125; 6.总结 full模式：类上标注@Configuration Lite模式：类上标注@Component、@ComponentScan、@Import、@ImportResource, 或者方法上面标注@Bean Full模式和Lite模式的唯一区别：Full模式的配置组件会被enhance（加强/代理），而Liter模式不会. Full模式带来增强的好处：Spring可以更好的管理Bean的依赖关系。比如@Bean之间方法之间的调用，其实是去Spring容器里去找Bean了，而并不是再生成了一个实例了。]]></content>
      <categories>
        <category>Spring Framework 系列</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot事件机制]]></title>
    <url>%2F2019%2F08%2F22%2Fspring%2FSpringBoot%E7%B3%BB%E5%88%97%2FSpring%20Boot%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.Spring Boot事件 序号 监听方法 Spring Boot事件 发生阶段说明 1 starting() ApplicationStartingEvent Spring 应用刚启动 2 environmentPrepared() ApplicationEnvironmentPreparedEvent ConfigurableEnvironment 准备妥当，允许将其调整 3 contextPrepared() ApplicationContextInitializedEvent ConfigurableApplicationContext 准备妥当，允许将其调整 4 contextLoaded() ApplicationPreparedEvent ConfigurableApplicationContext 已装载，但仍未启动 5 started() ApplicationStartedEvent ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成 6 running() ApplicationReadyEvent Spring 应用正在运行 7 failed() ApplicationFailedEvent Spring 应用运行失败 2.Spring Context事件 序号 spring context事件 发生阶段说明 1 ContextStartedEvent Lifecycle.start()方法 2 ContextRefreshedEvent Spring Bean已初始化完成 3 ContextClosedEvent Spring 容器关闭 4 ContextStoppedEvent Lifecycle.stop()方法 3.测试代码3.1.ApplicationStartingEvent123456public class StartingEventListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationStartingEvent event) &#123; System.err.println("1.ApplicationStartingEvent ...starting()"); &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot 系列</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot启动说明]]></title>
    <url>%2F2019%2F08%2F20%2Fspring%2FSpringBoot%E7%B3%BB%E5%88%97%2FSpring%20Boot%E5%90%AF%E5%8A%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[1.Spring Boot启动流程简述]]></content>
      <categories>
        <category>Spring Boot 系列</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP代理详解]]></title>
    <url>%2F2019%2F08%2F13%2Fspring%2FSpringFramework%E7%B3%BB%E5%88%97%2FSpring%20AOP%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.AOP执行流程 2.@EnableAspectJAutoProxy处理123456789101112131415161718public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //这里注册AnnotationAwareAspectJAutoProxyCreator.class处理类 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); if (enableAspectJAutoProxy != null) &#123; //jdk动态代理 = false cglib动态代理 = true (默认为false) if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); &#125; // 执行targer方法时，内部方法是否需要代理 (默认为false) if (enableAspectJAutoProxy.getBoolean("exposeProxy")) &#123; AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); &#125; &#125;&#125; 2.1. AnnotationAwareAspectJAutoProxyCreator类结构图 3.bean实例化之前过程 AbstractAutoProxyCreator#postProcessBeforeInstantiation 12345678910111213public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) &#123; ... // 是否结构化 //是否需要跳过 if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; ... return null;&#125; 3.1. 判断是否是基础类 AnnotationAwareAspectJAutoProxyCreator#isInfrastructureClass 123456789101112protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) &#123; boolean retVal = Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass); return retVal;&#125;protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) &#123; return (super.isInfrastructureClass(beanClass) || (this.aspectJAdvisorFactory != null &amp;&amp; this.aspectJAdvisorFactory.isAspect(beanClass)));//class是否有@Aspect注解&#125; 3.2. 判断是否跳过bean AspectJAwareAdvisorAutoProxyCreator#shouldSkip 123456789101112131415161718192021protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) &#123; // TODO: Consider optimization by caching the list of the aspect names List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); ... return super.shouldSkip(beanClass, beanName);&#125;public List&lt;Advisor&gt; findAdvisorBeans() &#123; // Determine list of advisor bean names, if not cached already. String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) &#123; //查找所有的 Advisor advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; &#125; if (advisorNames.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; ... return advisors;&#125; 3.3. 构建AspectJ Advisor 调用链路 BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors ReflectiveAspectJAdvisorFactory.getAdvisors ReflectiveAspectJAdvisorFactory.getAdvisor new InstantiationModelAwarePointcutAdvisorImpl() InstantiationModelAwarePointcutAdvisorImpl.instantiateAdvice ReflectiveAspectJAdvisorFactory.getAdvice BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors 12345678910111213141516171819202122232425262728293031String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false);for (String beanName : beanNames) &#123; if (!isEligibleBean(beanName)) &#123; continue; &#125; // We must be careful not to instantiate beans eagerly as in this case they // would be cached by the Spring container but would not have been weaved. Class&lt;?&gt; beanType = this.beanFactory.getType(beanName); if (beanType == null) &#123; continue; &#125;//如果该类有@AspectJ注解if (this.advisorFactory.isAspect(beanType)) &#123; aspectNames.add(beanName); AspectMetadata amd = new AspectMetadata(beanType, beanName); if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123; MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); //查找该类对应Advisor List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) &#123; this.advisorsCache.put(beanName, classAdvisors); &#125; else &#123; this.aspectFactoryCache.put(beanName, factory); &#125; advisors.addAll(classAdvisors); &#125;&#125;... 1234567891011121314public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123; Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();... List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();//查找AdvisorMethods 方法 for (Method method : getAdvisorMethods(aspectClass)) &#123; Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125;... return advisors;&#125; ReflectiveAspectJAdvisorFactory#getAdvisorMethods 12345678910111213141516171819202122232425static &#123; Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;( new InstanceComparator&lt;&gt;( //🚩第一次排序 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class), (Converter&lt;Method, Annotation&gt;) method -&gt; &#123; AspectJAnnotation&lt;?&gt; annotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method); return (annotation != null ? annotation.getAnnotation() : null); &#125;); Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName); METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);&#125;private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) &#123; final List&lt;Method&gt; methods = new ArrayList&lt;&gt;(); ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123; // 排出 pointcuts 注解 if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) &#123; methods.add(method); &#125; &#125;); //排序 methods.sort(METHOD_COMPARATOR); return methods;&#125; ReflectiveAspectJAdvisorFactory#getAdvisor 1234567891011public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,int declarationOrderInAspect, String aspectName) &#123; ... //表达式 AspectJExpressionPointcut expressionPointcut = getPointcut( candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()); if (expressionPointcut == null) &#123; return null; &#125;//返回包装过后的advisorreturn new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,this, aspectInstanceFactory, declarationOrderInAspect, aspectName);&#125; 4.bean初始化之后过程 AbstractAutoProxyCreator#wrapIfNecessary 1234567891011121314151617181920protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; ... if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; //获取该bean对应的特定拦截器 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); //如果有特定拦截器,则需要创建代理对象 if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); //创建代理对象 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; ... return bean;&#125; AbstractAdvisorAutoProxyCreator#findEligibleAdvisors 12345678910111213protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; //获取缓存中存在的Advisor List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); //找到符合该bean所对应的Advisor List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); //增强advisor extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; //advisor 排序 eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; AopUtils#canApply 123456789101112131415161718192021222324public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; //类织入 if (!pc.getClassFilter().matches(targetClass)) &#123; return false; &#125; ... Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(); if (!Proxy.isProxyClass(targetClass)) &#123; classes.add(ClassUtils.getUserClass(targetClass)); &#125; classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); //判断targetClass 是否有符合条件的Advisor for (Class&lt;?&gt; clazz : classes) &#123; Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) &#123; if (introductionAwareMethodMatcher != null ? introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) : methodMatcher.matches(method, targetClass)) &#123; return true; &#125; &#125; &#125; return false;&#125; AspectJAwareAdvisorAutoProxyCreator#sortAdvisors 排序过程调用链路 AspectJAwareAdvisorAutoProxyCreator.sortAdvisors PartialOrder.sort PartialOrder.addNewPartialComparable PartialOrder.addDirectedLinks AspectJPrecedenceComparator.compare AspectJPrecedenceComparator.comparePrecedenceWithinAspect 12345678910protected List&lt;Advisor&gt; sortAdvisors(List&lt;Advisor&gt; advisors) &#123; List&lt;PartiallyComparableAdvisorHolder&gt; partiallyComparableAdvisors = new ArrayList&lt;&gt;(advisors.size()); for (Advisor element : advisors) &#123; partiallyComparableAdvisors.add( new PartiallyComparableAdvisorHolder(element, DEFAULT_PRECEDENCE_COMPARATOR)); &#125; //排序 List&lt;PartiallyComparableAdvisorHolder&gt; sorted = PartialOrder.sort(partiallyComparableAdvisors);...&#125; 123456789101112131415161718192021222324252627282930313233343536373839public int compare(Advisor o1, Advisor o2) &#123; int advisorPrecedence = this.advisorComparator.compare(o1, o2); if (advisorPrecedence == SAME_PRECEDENCE &amp;&amp; declaredInSameAspect(o1, o2)) &#123; advisorPrecedence = comparePrecedenceWithinAspect(o1, o2); &#125; return advisorPrecedence;&#125;//🚩如果order相等的情况下，值越小优先级越高private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) &#123; boolean oneOrOtherIsAfterAdvice = (AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2)); int adviceDeclarationOrderDelta = getAspectDeclarationOrder(advisor1) - getAspectDeclarationOrder(advisor2); //🚩首先判断是否是AfterAdvice，如果是AfterAdvice，则值越小优先级越高 if (oneOrOtherIsAfterAdvice) &#123; if (adviceDeclarationOrderDelta &lt; 0) &#123; return LOWER_PRECEDENCE; &#125; else if (adviceDeclarationOrderDelta == 0) &#123; return SAME_PRECEDENCE; &#125; else &#123; return HIGHER_PRECEDENCE; &#125; &#125; //🚩如果不是AfterAdvice，则值越大优先级越高 else &#123; if (adviceDeclarationOrderDelta &lt; 0) &#123; return HIGHER_PRECEDENCE; &#125; else if (adviceDeclarationOrderDelta == 0) &#123; return SAME_PRECEDENCE; &#125; else &#123; return LOWER_PRECEDENCE; &#125; &#125;&#125; 5.创建bean代理过程 AbstractAutoProxyCreator#createProxy 12345678910111213141516171819202122protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123;... ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) &#123; if (shouldProxyTargetClass(beanClass, beanName)) &#123; //cglib代理 proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource);... return proxyFactory.getProxy(getProxyClassLoader());&#125; DefaultAopProxyFactory#createAopProxy 12345678910111213141516public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); ... if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; //jdk动态代理 return new JdkDynamicAopProxy(config); &#125; //cglib动态代理 return new ObjenesisCglibAopProxy(config); &#125; else &#123; //jdk动态代理 return new JdkDynamicAopProxy(config); &#125;&#125; 5.1.获取beanproxy流程 5.2.Prxoy类结构图 6.拦截器执行invoke之前动作 JdkDynamicAopProxy#invoke 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Object target = null; try &#123; //处理equals方法 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; return equals(args[0]); &#125; //处理hashcode方法 else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123; return hashCode(); &#125; ... Object retVal; //如果需要内部方法调用时也需要进行代理，则执行此动作 if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; target = targetSource.getTarget(); Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null); //获取执行的拦截器链，同时将advisor转换为MethodInterceptor List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); //如果责任链为空，则直接执行目标方法 if (chain.isEmpty()) &#123; Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; ... //执行拦截器链 MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); &#125; return retVal; &#125; finally &#123; ... if (setProxyContext) &#123; AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 6.1.设置内部方法之间的调用使用代理12345678910111213141516171819202122232425262728//如果需要内部方法调用时也需要进行代理，则执行此动作if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true;&#125;...finally &#123; ... if (setProxyContext) &#123; AopContext.setCurrentProxy(oldProxy); &#125;&#125;//使用方式class AppleServiceImpl implements AppleService&#123; @Override public void a &#123; System.out.println("测试a方法...."); &#125; @Override public void b() &#123; //方法内部进行拦截，需要设置exposeProxy = true System.out.println("测试b方法...."); ((AppleService)AopContext.currentProxy()).a(); &#125;&#125; 7.拦截方法执行invoke动作 ReflectiveMethodInvocation#proceed【迭代执行MethodInterceptor链中的invoke方法]】 1234567891011public Object proceed() throws Throwable &#123; // We start with an index of -1 and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); ... //迭代执行拦截器链 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);&#125; 执行顺序 12345678910111213try &#123; try &#123; doAround();//对应@Around注解的方法切面逻辑 doBefore();//对应@Before注解的方法切面逻辑 method.invoke(); doAorund();//对应@Around注解的方法切面逻辑 &#125; finally &#123; doAfter();//对应@After注解的方法切面逻辑 &#125; doAfterReturning();//对应@AfterReturning注解的方法切面逻辑 &#125; catch(Exception e) &#123; doAfterThrowing();//对应@AfterThrowing注解的方法切面逻辑 &#125; 8.用idea工具进行debug时踩坑记录12345678910111213public class StandardInvocationHandler implements InvocationHandler &#123; private Object targer; public StandardInvocationHandler(Object targer) &#123; this.targer = targer; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用方法：[" + method.getName() + "] 执行前"); Object result = method.invoke(targer, args); System.out.println("调用方法：[" + method.getName() + "] 执行后"); return result; &#125;&#125; 12345678910public class ApplicationJDKMain &#123; public static void main(String[] args) &#123; AppleService service = new AppleServiceImpl(); InvocationHandler handler = new StandardInvocationHandler(service); AppleService proxyInstance = (AppleService) Proxy.newProxyInstance(AppleService.class.getClassLoader(), new Class[] &#123; AppleService.class &#125;, handler); proxyInstance.eatApple(); &#125;&#125; 以上代码在用idea进行代码调试时，会出现以下现象 12345&gt;调用方法：[toString] 执行前&gt;调用方法：[toString] 执行后&gt;调用方法：[toString] 执行前&gt;调用方法：[toString] 执行后&gt; 不用debug模式，则不会出现这种情况 这不是IDEA中的错误。如果在没有任何断点的情况下调试此方法，则可能会得到与预期相同的结果。但是如果你设置一些断点，IDEA将尝试调用toString（）方法,调试器都将重新评估范围内的每个变量（通过调用toString()）来刷新其值. 参考：https://stackoverflow.com/questions/42972312/intellij-idea-debug-enter-method-multiple-times]]></content>
      <categories>
        <category>Spring Framework 系列</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC过程]]></title>
    <url>%2F2019%2F08%2F13%2Fspring%2FSpringFramework%E7%B3%BB%E5%88%97%2FSpringIOC%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Spring Framework 系列</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot自动装配]]></title>
    <url>%2F2019%2F08%2F10%2Fspring%2FSpringBoot%E7%B3%BB%E5%88%97%2FSpring%20Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.自动装配流程解析 2.三大核心注解@Configuration @EnableAutoConfiguration @ComponentScan 3.@Conditional条件注解说明 @ConditionalOnClass ： classpath中存在该类时起效@ConditionalOnMissingClass ： classpath中不存在该类时起效@ConditionalOnBean ： DI容器中存在该类型Bean时起效@ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效@ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效@ConditionalOnExpression ： SpEL表达式结果为true时@ConditionalOnProperty ： 参数设置或者值一致时起效@ConditionalOnResource ： 指定的文件存在时起效@ConditionalOnJndi ： 指定的JNDI存在时起效@ConditionalOnJava ： 指定的Java版本存在时起效@ConditionalOnWebApplication ： Web应用环境下起效@ConditionalOnNotWebApplication ： 非Web应用环境下起效]]></content>
      <categories>
        <category>Spring Boot 系列</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean的生命周期]]></title>
    <url>%2F2019%2F08%2F02%2Fspring%2FSpringFramework%E7%B3%BB%E5%88%97%2FSpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.整体流程图 Spring Bean对象的可扩展性主要就是依靠InstantiationAwareBeanPostProcessor和BeanPostProcessor来实现的，其中重要的2个接口: InstantiationAwareBeanPostProcessor 主要是作用于实例化阶段。 BeanPostProcessor 主要作用与初始化阶段。 12345678public void refresh() throws BeansException, IllegalStateException &#123; // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory);&#125; 2.简化版invokeBeanFactoryPostProcessors过程123456789101112131415161718192021222324252627282930313233if (beanFactory instanceof BeanDefinitionRegistry) &#123; for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; // 🚩1. 首先执行系统已经存在的，并且实现BeanDefinitionRegistryPostProcessor接口的类 registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; //🚩其次从注册的beanDefinitionMap中查找，实现BeanDefinitionRegistryPostProcessor接口的类 String[] postProcessorNames=beanFactory.getBeanNamesForType (BeanDefinitionRegistryPostProcessor.class, true, false); //🚩 分别按照优先级 [PriorityOrdered-&gt;Ordered-&gt;无序] 来执行 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); //⭐️ 这里执行实现BeanFactoryPostProcessor 接口的类 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);&#125;//🚩2. 其次从注册的beanDefinitionMap中查找，实现BeanFactoryPostProcessor接口的类String[] postProcessorNames=beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);//🚩 分别优先级执行：PriorityOrderedinvokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);//🚩 分别优先级执行：OrderedinvokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);//🚩 分别优先级执行：无序invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); 12345678910111213141516171819202122232425262728293031323334353637383940//备注：BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor //简单理解：首先处理 BeanDefinitionRegistryPostProcessor 接口List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();class MyBean1 implements BeanDefinitionRegistryPostProcessor &#123; System.out.println("系统自带的最先执行：BeanDefinitionRegistryPostProcessor"); //添加 registryProcessors.add(MyBean1);&#125;class MyBean2 implements BeanDefinitionRegistryPostProcessor,PriorityOrdered &#123; System.out.println("我是第二个执行：BeanDefinitionRegistryPostProcessor"); //添加 registryProcessors.add(MyBean2);&#125;class MyBean3 implements BeanDefinitionRegistryPostProcessor,Ordered &#123; System.out.println("我是第三个执行：BeanDefinitionRegistryPostProcessor"); //添加 registryProcessors.add(MyBean3);&#125;class MyBean4 implements BeanDefinitionRegistryPostProcessor &#123; System.out.println("我是第四个执行：BeanDefinitionRegistryPostProcessor"); //添加 registryProcessors.add(MyBean4);&#125;----------------------------------//其次处理 BeanFactoryPostProcessor接口invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);----------------------------------//再次处理 BeanFactoryPostProcessor接口 ,从注册的beanDefinitionMap中查找class MyBean5 implements BeanFactoryPostProcessor ,PriorityOrdered&#123; System.out.println("执行：BeanFactoryPostProcessor");&#125;class MyBean6 implements BeanFactoryPostProcessor ,Ordered&#123; System.out.println("执行：BeanFactoryPostProcessor");&#125;class MyBean7 implements BeanFactoryPostProcessor &#123; System.out.println("执行：BeanFactoryPostProcessor");&#125; 最终执行的结果在BeanFactory如下： BeanFactoryPostProcessor接口 SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor ConfigurationClassPostProcessor ConfigFileApplicationListener PropertySourcesPlaceholderConfigurer ConfigurationBeanFactoryMetadata EventListenerMethodProcessor BeanDefinitionRegistryPostProcessor接口 SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor ConfigurationClassPostProcessor 3.简化版的registerBeanPostProcessors过程12345678910111213141516171819202122232425262728293031323334//从注册的beanDefinitionMap中查找String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);for (String ppName : postProcessorNames) &#123; // 优先级：PriorityOrdered if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; // 优先级：Ordered else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; // 优先级：无 else &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125;&#125;//按顺序添加registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);registerBeanPostProcessors(beanFactory, orderedPostProcessors);registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);registerBeanPostProcessors(beanFactory, internalPostProcessors); 最终执行的结果在BeanFactory如下： BeanPostProcessor接口 【⭐️】 ApplicationContextAwareProcessor ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor PostProcessorRegistrationDelegate$BeanPostProcessorChecker ConfigurationPropertiesBindingPostProcessor CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor ApplicationListenerDetector MergedBeanDefinitionPostProcessor接口 CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor ApplicationListenerDetector InstantiationAwareBeanPostProcessor接口 【⭐️】 ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor 4.注册Bean的过程AbstractBeanFactory#doGetBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //缓存 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 判断循环引用,抛异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; &#125; //----------------- // 获取bean的依赖，实例化bean前先实例化依赖。 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; &#125; &#125; // Create bean instance // 创建 bean 实例 // 单例模式 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -&gt; &#123; return createBean(beanName, mbd, args); &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型模式 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125;&#125; 先getSingleton()从缓存中获取Bean，如果没有则创建。 创建过程先检查有无循环依赖，有则抛出异常。 实例化bean前先实例化所依赖的对象。 AbstractAutowireCapableBeanFactory#createBean12345678910111213141516protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; try &#123; // 🚩实例化之前动作 处理InstantiationAwareBeanPostProcessor Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; ... try &#123; // 🚩 创建实例 Object beanInstance = doCreateBean(beanName, mbdToUse, args); return beanInstance; &#125; &#125; resolveBeforeInstantiation 123456789101112131415161718protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) &#123; //调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = (bean != null); &#125; return bean;&#125; applyBeanPostProcessorsBeforeInstantiation 12345678910111213protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 执行所有InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null;&#125; AbstractAutowireCapableBeanFactory#doCreateBean123456789101112131415161718192021222324252627protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; if (instanceWrapper == null) &#123; //创建bean实例 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; // applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; mbd.postProcessed = true; &#125; &#125; // Initialize the bean instance. 初始化 bean Object exposedObject = bean; try &#123; populateBean(beanName, mbd, instanceWrapper); exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; // Register bean as disposable. 注册bean销毁方法 try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; return exposedObject;&#125; applyMergedBeanDefinitionPostProcessors 12345678protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof MergedBeanDefinitionPostProcessor) &#123; MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); &#125; &#125;&#125; AbstractAutowireCapableBeanFactory#populateBean123456789101112131415161718protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 执行实例化后方法 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (pvs != null) &#123; //其他属性填充 applyPropertyValues(beanName, mbd, bw, pvs); &#125;&#125; AbstractAutowireCapableBeanFactory#initializeBean12345678910111213141516171819protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123; //Aware接口方法执行 invokeAwareMethods(beanName, bean); Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //初始化之前 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //初始化 invokeInitMethods(beanName, wrappedBean, mbd); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //初始化之后 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; invokeAwareMethods 12345678910111213141516private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; applyBeanPostProcessorsBeforeInitialization 1234567891011public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result;&#125; applyBeanPostProcessorsAfterInitialization 1234567891011public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result;&#125; 5.销毁bean的过程AbstractBeanFactory#registerDisposableBeanIfNecessary12345678910111213141516171819protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) &#123; AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null); //判断是否满足条件 if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123; if (mbd.isSingleton()) &#123; // Register a DisposableBean implementation that performs all destruction // work for the given bean: DestructionAwareBeanPostProcessors, // DisposableBean interface, custom destroy method. registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); &#125; else &#123; // A bean with a custom scope... Scope scope = this.scopes.get(mbd.getScope()); scope.registerDestructionCallback(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc)); &#125; &#125;&#125; 判断是否满足条件 1.是否存在：对DestructionAwareBeanPostProcessors接口的处理的实现类，目前有CommonAnnotationBeanPostProcessor 可以来处理 @PreDestroy 注解 2.是否有销毁方法：bean是否有实现 DisposableBean 接口 或者 bean是否存在有销毁的方法名 3.bean是否是单例模式 DisposableBeanAdapter#hasApplicableProcessors1234567891011121314public static boolean hasApplicableProcessors(Object bean, List&lt;BeanPostProcessor&gt; postProcessors) &#123; if (!CollectionUtils.isEmpty(postProcessors)) &#123; for (BeanPostProcessor processor : postProcessors) &#123; //DestructionAwareBeanPostProcessor 接口 if (processor instanceof DestructionAwareBeanPostProcessor) &#123; DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor; if (dabpp.requiresDestruction(bean)) &#123; return true; &#125; &#125; &#125; &#125; return false;&#125; DisposableBeanAdapter#destroy12345678910111213141516171819202122232425public void destroy() &#123; //首先执行 CommonAnnotationBeanPostProcessor中对 @PreDestroy 注解的处理 if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123; processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; //其次执行 bean实现DisposableBean接口 if (this.invokeDisposableBean) &#123; try &#123; ((DisposableBean) this.bean).destroy(); &#125; &#125; &#125; //最后执行 @Bean(destroyMethod="") 或者 xml中配置的destroy-method="destroyMethod" if (this.destroyMethod != null) &#123; invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToInvoke = determineDestroyMethod(this.destroyMethodName); if (methodToInvoke != null) &#123; invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Spring Framework 系列</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
